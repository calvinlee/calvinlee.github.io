
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>且听风吟</title>
  <meta name="author" content="Calvin Lee">

  
  <meta name="description" content="HBoot：http://alpharev.nl/
ROM Update Utility（RUU）
http://www.freeyourandroid.com/guide/flashing-ruu-htc
http://shipped-roms.com/index.php?category= &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://calvinlee.github.io/blog/page/6">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="且听风吟" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">且听风吟</a></h1>
  
    <h2>Don't panic! I'm a programmer.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:calvinlee.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/links.html">Links</a></li>
  <li><a href="/music.html">Music</a></li>
  <li><a href="/about.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/18/bravo-flash-terms-and-issues/">Bravo Flash Terms and Issues</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-18T00:00:00+08:00" pubdate data-updated="true">Mar 18<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/18/bravo-flash-terms-and-issues/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/18/bravo-flash-terms-and-issues/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>HBoot：<a href="http://alpharev.nl/">http://alpharev.nl/</a>
ROM Update Utility（RUU）
<a href="http://www.freeyourandroid.com/guide/flashing-ruu-htc">http://www.freeyourandroid.com/guide/flashing-ruu-htc</a>
<a href="http://shipped-roms.com/index.php?category=android&amp;model=Bravo">http://shipped-roms.com/index.php?category=android&amp;model=Bravo</a></p>

<p>app2sd
<a href="http://www.mrpeng.info/2010/12/data2sd_on_desire/">http://www.mrpeng.info/2010/12/data2sd_on_desire/</a>
app2ext</p>

<p>data2ext
data2whatever:<a href="http://forum.xda-developers.com/showthread.php?t=867049&amp;page=3">http://forum.xda-developers.com/showthread.php?t=867049&amp;page=3</a></p>

<p>Bootloader(HBoot)&mdash;>recovery
Hboot Definition:
Hboot is most commonly known to the Android phone community as the first stage before the phone goes through its boot cycle.
In a boot control scenario, the hboot provides an avenue of choice between functions up to and including a standard boot. Other choices may be things such as recovery branch, or factory reset.
Hboot (aka: bootloader) also serves as a gatekeeper for software updates to the device. The hboot commonly uses encryption technology that will check to see if the package being written is &ldquo;signed.&rdquo; This function is often referred to as &ldquo;locked.&rdquo;
In any event, the hboot is a critical component. Without it, a device simply will not work.</p>

<p>Nand backup</p>

<p><a href="http://stackoverflow.com/questions/3465259/can-someone-explain-these-android-rom-hacking-terms-hboot-bootloader-radio-re">http://stackoverflow.com/questions/3465259/can-someone-explain-these-android-rom-hacking-terms-hboot-bootloader-radio-re</a></p>

<p>非常好的解释：
<a href="http://androidforums.com/evo-4g-all-things-root/278898-android-partitions-kernels-explained.html">http://androidforums.com/evo-4g-all-things-root/278898-android-partitions-kernels-explained.html</a></p>

<h3>android internal storage partition</h3>

<p><a href="https://www.google.com/search?client=ubuntu&amp;channel=fs&amp;q=android+internal+memory+partition&amp;ie=utf-8&amp;oe=utf-8">https://www.google.com/search?client=ubuntu&amp;channel=fs&amp;q=android+internal+memory+partition&amp;ie=utf-8&amp;oe=utf-8</a>
<a href="http://www.addictivetips.com/mobile/android-partitions-explained-boot-system-recovery-data-cache-misc/">http://www.addictivetips.com/mobile/android-partitions-explained-boot-system-recovery-data-cache-misc/</a>
<a href="http://stackoverflow.com/questions/4634774/android-memory-types-ram-v-internal-memory">http://stackoverflow.com/questions/4634774/android-memory-types-ram-v-internal-memory</a>
So, with all that in mind:</p>

<pre><code>Your 512MB of ROM is the on-board flash storage, hearkening back to the old "flash ROM" term
Your "Internal phone storage" in settings it the available space in the data partition for end-user apps and data (one of the reasons why I don't use this term to refer to the on-board flash storage as a whole)
Your "SD card" is more generically referred to in Android as external storage, which on many devices is some form of SD card, though it could actually be just another partition of the on-board flash storage designated as serving in the role of external storage
</code></pre>

<p>HTC desire:
<a href="http://forum.xda-developers.com/wiki/HTC_Desire">http://forum.xda-developers.com/wiki/HTC_Desire</a>
Memory: RAM 576MB, ROM 512MB Flash
$ adb shell cat /proc/mtd
+++++++++++++++++++++++++++++++++++++++++++++++
Fastboot
<a href="http://en.wikipedia.org/wiki/Fastboot">http://en.wikipedia.org/wiki/Fastboot</a>
Utilizing the Fastboot protocol requires that the device be started in a boot loader or Second Program Loader mode in which only the most basic hardware initialization is performed. After enabling the protocol on the device itself it will accept any command sent to it over USB via a command line. Some of most commonly used fastboot commands include:
<a href="http://wiki.cyanogenmod.com/wiki/Fastboot#Typical_Partition_Layout">http://wiki.cyanogenmod.com/wiki/Fastboot#Typical_Partition_Layout</a>
<a href="http://android-dls.com/wiki/index.php?title=Fastboot">http://android-dls.com/wiki/index.php?title=Fastboot</a>
<a href="http://elinux.org/Android_Fastboot">http://elinux.org/Android_Fastboot</a></p>

<p>HBoot可以在fastboot和hboot之间切换
在fastboot模式时，如果是S-OFF，那么可以使用fastboot来刷写image
<a href="http://wiki.cyanogenmod.com/wiki/Fastboot#fastboot_--help">http://wiki.cyanogenmod.com/wiki/Fastboot#fastboot_&#8211;help</a></p>

<p>$ ./fastboot devices
SH12RPL03652    fastboot</p>

<p>对Nexus s 和 Xoom,可以使用fastboot oem unlock
++++++++++++++++++++++++++++++++++++++++++++++
IPL VS SPL
+++++++++++++++++++++++++++++++++++++++++++++++
HBoot参数详解
　　BRAVO PVT4 SHIP S-ON
　　HBOOT-0.93.0001
　　MICROP-031d
　　RADIO-5.10.05.23
　　Aug 10 2010,17:52:18
　　BRAVO：这个是手机型号的内部开发代号。</p>

<p>　　PVT(或者是EVT，DVT，CVT)：是代表手机的版本类型。
　　一台手机从研发到上市，可能会经历多次版本上的调试和改动，版本类型标志着机器是什么时候的产物，如下：
　　EVT：工程机，研发阶段机器的型号;
　　DVT：开发机，特殊开发用途机器的型号;
　　CVT：商用机，交付运营商的机器的型号;
　　PVT：量产机，最终上市的零售版机器的型号。(PVT1：第1批量产机)
　　SHIP/ENG：手机HBOOT(SPL)的版本。
　　SHIP：shippment的缩写，出货的意思，零售版的HBOOT版本。
　　ENG：Engineer的缩写，工程的意思，修改版的HBOOT版本。
　　S-ON(或者是S-OFF)：
　　S代表Security Lock，即安全锁。HTC在手机内部设置了一个安全锁，用来控制系统分区的读写状态。
　　S-ON：安全锁开;
　　S-OFF：安全锁关。
　　HBOOT-0.93.0001
　　这里显示了HBOOT的版本号，HBOOT是一个很特殊的部分，刷坏了这里，手机就会变砖，类似于升级电脑的BIOS，刷错了BIOS，你只能返厂用特殊的擦写工具来恢复了，所以，对HBOOT的操作要特别的注意，如非必要，不要去轻易刷写此分区!<br/>
　　RADIO-5.10.05.23
　　这里显示了RADIO的版本号，同样的，RADIO会随着官方系统的升级而跟着升级，RADIO是负责信号和硬件驱动的，理论上讲，应该是越高版本越好，当然也不是绝对，也需要要看情况的，就像电脑上的驱动，最新的并不一定是最好的。</p>

<p>++++++++++++++++++++++++++++++++++++
第一级: Root
所谓root，就是linux系统的最高权限用户。因为android基本就是精简的linux+驱动+dalvik java虚拟机。所以获取了root，你就可以对手机里的软件进行修改了。在国内的手机软件网站能找到什么一键root的工具。root成功的标志一般是手机的程序图标里多了一个“授权管理”，这是就可以对需要root权限才能运行的软件授权了。</p>

<p>第二级：Recovery
所谓recovery,就是一个用于更新rom的基本完备的小系统，相当于电脑崩溃后用来修复系统的启动光盘。对了，解释下rom，rom本来的意思是只读内存，用在手机上呢表示用户不能修改的内存。注意，是用户不能修改，实际上是可以改的，还改的很快呢！不然也没recovery什么事了。也就是说手机出厂时原装的系统，类似于买电脑已经预装了系统，手机厂家是不希望用户乱改的。那厂家要刷rom怎么办呢? 因为他们能进入手机里他们的recovery，所以这不是问题。而有些不安分的人玩着觉得不爽了，觉得自己能搞出更好用的rom。而要刷自己的rom，那么就必须干掉原先系统里的recovery，刷自己的recovery，这是需要有root为前提的。unrevoked.com提供了windows下的工具，将root和刷recovery合二为一，默认刷入的是Clockwork mod的recovery 2.5版.当然也可以刷入你指定的recovery。
具体操作过程中会遇到两次驱动的问题。一个驱动是手机运行状态下的usb驱动，这个通过安装htc sync就能解决。一个驱动是用于手机调试的hboot usb驱动，只有进入到手机的hboot状态，windows才会提示你安装，网上很多教程都附有下载链接。本版版主的教程里也有。
还有一个问题是会遇到Backup CID的问题,不细说，搜搜网上的教程吧。
当看到unrevoked出现Done的时候，恭喜你，你进入了Class 2.
成功刷入recovery后还有一个战利品是可以更新手机的radio,我理解就是手机无线部分的底层代码，目前最新的版本是5.14。
刷了rom后，别忘了wipe user data和cache再重启。</p>

<p>第三级：S-OFF
S-OFF,就是security off的意思。意思是手机上的一个硬件安全标识处于off的状态，这时可以用android开发工具里的fastboot往手机里刷任何东西。手机出厂时可都是S-ON的。S-OFF了之后，刷recovery都可以不用unrevoked了，直接用fastboot吧。所谓刷s-off，是说这个硬件咱改不了，只能刷手机软件，让它不去管这个什么安全标识，该干嘛就干嘛。
看到这里，你可能觉得很晕，不是说s-on的系统就是不能改的吗，怎么刷recovery的时候没人提它呢？我刷recovery的时候还是s-on呢！
我以为unrevoked的行为本质是也是一种软s-off的方法，因为它“非法”修改了recovery,但是它没有解决hboot的s-on的问题。人家是有道理的：hboot比recovery启动的顺序更靠前，搞坏的话，手机就彻底变砖了。
本级这里的S-OFF，特指连hboot都已经被修改了，系统彻底被s-off了，彻底被free了。
刷S-OFF的风险在于，如果你把rom刷坏了，可以通过recovery修复；如果你把recovery刷坏了，厂家进入hboot还可以把recovery给你刷回来。hboot是手机变砖修复的最后一丝希望，如果hboot都被搞坏了，那估计只能把rom芯片取下来拿到编程器上刷了。一般来讲没必要修改，那什么时候修改hboot的收益能引诱我们冒这个风险呢？
对我而言，一个就是可以通过fastboot刷各种recovery,update,splash，而不必仰仗各种工具，反复的重启。一个就是因为Adam Green的Oxygen 2。
好吧，我承认我是AdamG的粉丝。Oxygen是一个来完全开源，代码都来自AOSP的以精简、稳定为追求的Gingerbread（就是android 2.3）的rom。另外，确实比较省电，据AdamG自己讲，电池最多能用到3天。由于比较精简，所以原先系统cache和system分区就能腾出不少空间。如果这些将近200M的空间拿来装我们自己的apk，就完全没必要去玩什么app2ext app2sd app2*了，还又快又省电。这也是AdamG为什么非常不情愿在Oxygen 2加入app2ext支持的原因。
所以，刷hboot最大的好处就是可以把这块空间腾出来。这个过程实际上也彻底屏蔽了hTC的安全标识，彻底s-off了，所以网上叫喊s-off的时候,干的其实是刷hboot的勾当。
干这个有工具吗？这个真还有。alpharev.nl上面提供一个iso文件和若干hboot映像的下载。有一个映像就是专供Oxygen的，你可以看到data分区的空间是多么大啊。具体方法就是用它提供的iso刻的光盘启动系统，并按提示连接手机，一切过程自动完成。不想去刻盘也可以用虚拟机vmware,只不过手机每次重启后都需要你点击vmware菜单里的removable devices里的high android phone将手机的usb连接重新接入虚拟机。
按我的经验，很可能会到手机型号不匹配的问题，网上有教程告诉你怎么做。
这事干完，你手机的hboot跟recovery版本都被翻新了。然后再用fastboot刷入Oxygen专供的hboot，然后就可以刷Oxygen 2了。不过因为这个hboot的cache分区很小,刷非Oxygen的其他rom和update的时候可能就不行了。</p>

<p>最后，祝你好运。刷机有风险，操作需谨慎。下载的非zip文件别忘了校对MD5或者SHA。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/17/insight-into-android-permission/">Android 权限机制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-17T00:00:00+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/17/insight-into-android-permission/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/17/insight-into-android-permission/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>概要</h3>

<p>Android基于Linux，Android的权限管理基于Linux的权限框架。此外，Android在此基础上为应用程序提供了permission机制，使得应用程序通过“申请-授予”的机制得以访问系统的敏感资源。权限的授予在应用程序安装过程中就已经确定了，在安装过程中，应用程序的gid，uid，pid已经gids都会被分配。Android不支持在运行时动态进行权限授予。<a href="http://developer.android.com/guide/topics/security/security.html#arch">Why?</a></p>

<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Group_identifier#Primary_vs._supplementary">http://en.wikipedia.org/wiki/Group_identifier#Primary_vs._supplementary</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/17/handy-toolbox/">Handy Toolbox</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-17T00:00:00+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/17/handy-toolbox/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/17/handy-toolbox/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这里记录一些我常用的一些方便高效的工具。</p>

<h3>Firefox</h3>

<ul>
<li><a href="http://vimperator.org/vimperator">Vimperator</a></li>
<li><a href="http://sessionmanager.mozdev.org/">Session Manager</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/evernote-web-clipper/">Evernote web clipper</a></li>
<li><a href="http://www.teesoft.info/content/view/118/1/lang,en/">Autopager</a></li>
</ul>


<h3>Thunderbird</h3>

<ul>
<li><a href="https://addons.mozilla.org/en-US/thunderbird/addon/lightning/?src=search">Lightning</a></li>
<li><a href="https://skydrive.live.com/redir.aspx?cid=71573c6596efd6ee&amp;resid=71573C6596EFD6EE!155&amp;parid=71573C6596EFD6EE!154">Firetray</a></li>
</ul>


<h3>画图</h3>

<ul>
<li><a href="https://skydrive.live.com/redir.aspx?cid=71573c6596efd6ee&amp;resid=71573C6596EFD6EE!146&amp;parid=71573C6596EFD6EE!145">JUDE</a> -UML工具</li>
<li><a href="https://skydrive.live.com/redir.aspx?cid=71573c6596efd6ee&amp;resid=71573C6596EFD6EE!196&amp;parid=71573C6596EFD6EE!145">Edraw</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/17/different-reference-types-in-java/">Java的四种引用类型</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-17T00:00:00+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/17/different-reference-types-in-java/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/17/different-reference-types-in-java/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java中有四种引用类型，按其引用强度由强到弱依次为：</p>

<pre><code>Strong reference &gt; Soft reference &gt; Weak reference &gt; Phantom reference
</code></pre>

<h3>Strong reference</h3>

<p>最常用的为strong reference，就是说只要某个对象还被一个强引用引用着，那么GC就不会回收它。使用强引用的一个弊端就是有可能引起内存泄漏。比如有一个hashmap集合，用来存储对象引用，如果你忘了在某个时机把这些元素remove掉，那么这些对象就会在这个hashmap的生命周期内被一直引用而不能被GC回收，更糟糕的是，如果这个对象体积很大，而又如果这个hashmap被声明为static的，那么随着程序的运行，内存总有被撑爆的那一刻。</p>

<h3>Soft reference</h3>

<p>而soft reference 就不同了，在内存资源极度紧张的情况下，GC会将被Soft reference 引用的对象回收以释放内存空间。这个特性非常适合用来做cache：在内存资源充裕的情况下，它和强引用一样，GC不会回收它，而在内存紧张的情况下，GC实在找不到更多可用的空间的情况下，Soft reference的对象会被回收掉。<br/>
以下代码展示了基于Soft reference的缓存类的使用：</p>

<pre><code>/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.providers.contacts;

import com.android.providers.contacts.ContactsDatabaseHelper.NicknameLookupColumns;
import com.android.providers.contacts.ContactsDatabaseHelper.Tables;
import com.google.android.collect.Maps;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import java.lang.ref.SoftReference;
import java.util.BitSet;
import java.util.HashMap;


/**
 * Cache for common nicknames.
 */
public class CommonNicknameCache  {

    // We will use this much memory (in bits) to optimize the nickname cluster lookup
    private static final int NICKNAME_BLOOM_FILTER_SIZE = 0x1FFF;   // =long[128]
    private BitSet mNicknameBloomFilter;

    private HashMap&lt;String, SoftReference&lt;String[]&gt;&gt; mNicknameClusterCache = Maps.newHashMap();

    private final SQLiteDatabase mDb;

    public CommonNicknameCache(SQLiteDatabase db) {
        mDb = db;
    }

    private final static class NicknameLookupPreloadQuery {
        public final static String TABLE = Tables.NICKNAME_LOOKUP;

        public final static String[] COLUMNS = new String[] {
            NicknameLookupColumns.NAME
        };

        public final static int NAME = 0;
    }

    /**
     * Read all known common nicknames from the database and populate a Bloom
     * filter using the corresponding hash codes. The idea is to eliminate most
     * of unnecessary database lookups for nicknames. Given a name, we will take
     * its hash code and see if it is set in the Bloom filter. If not, we will know
     * that the name is not in the database. If it is, we still need to run a
     * query.
     * &lt;p&gt;
     * Given the size of the filter and the expected size of the nickname table,
     * we should expect the combination of the Bloom filter and cache will
     * prevent around 98-99% of unnecessary queries from running.
     */
    private void preloadNicknameBloomFilter() {
        // 这个filter被设计成一个简化的hash表（没有处理hash冲突的情况，实际上也没有必要）
        mNicknameBloomFilter = new BitSet(NICKNAME_BLOOM_FILTER_SIZE + 1);
        Cursor cursor = mDb.query(NicknameLookupPreloadQuery.TABLE,
                NicknameLookupPreloadQuery.COLUMNS,
                null, null, null, null, null);
        try {
            int count = cursor.getCount();
            for (int i = 0; i &lt; count; i++) {
                cursor.moveToNext();
                String normalizedName = cursor.getString(NicknameLookupPreloadQuery.NAME);
                int hashCode = normalizedName.hashCode();
                // 将元素put进hash表（有可能冲突），参见HashMap的put实现
                // 和hashcode做与运算的这个值必须是“hash表长度-1”
                mNicknameBloomFilter.set(hashCode &amp; NICKNAME_BLOOM_FILTER_SIZE);
            }
        } finally {
            cursor.close();
        }
    }

    /**
     * Returns nickname cluster IDs or null. Maintains cache.
     */
    protected String[] getCommonNicknameClusters(String normalizedName) {
        if (mNicknameBloomFilter == null) {
            preloadNicknameBloomFilter();
        }

        int hashCode = normalizedName.hashCode();

        // 如果没有找到，说明cache中**一定**不存在这个key所对应的值;
        // 如果找到了，说明cache中**可能**存在这个key对应的值，需要进一步到cache中查找
        if (!mNicknameBloomFilter.get(hashCode &amp; NICKNAME_BLOOM_FILTER_SIZE)) {
            return null;
        }

        SoftReference&lt;String[]&gt; ref;
        String[] clusters = null;

        // 注意：这里需要同步对cache的访问
        synchronized (mNicknameClusterCache) {
            if (mNicknameClusterCache.containsKey(normalizedName)) {
                ref = mNicknameClusterCache.get(normalizedName);
                if (ref == null) {
                    return null;
                }
                clusters = ref.get();
            }
        }

        // 没有命中，这时才需要到DB中加载，并加入cache
        if (clusters == null) {
            clusters = loadNicknameClusters(normalizedName);
            ref = clusters == null ? null : new SoftReference&lt;String[]&gt;(clusters);
            synchronized (mNicknameClusterCache) {
                mNicknameClusterCache.put(normalizedName, ref);
            }
        }
        return clusters;
    }

    private interface NicknameLookupQuery {
        String TABLE = Tables.NICKNAME_LOOKUP;

        String[] COLUMNS = new String[] {
            NicknameLookupColumns.CLUSTER
        };

        int CLUSTER = 0;
    }

    protected String[] loadNicknameClusters(String normalizedName) {
        String[] clusters = null;
        Cursor cursor = mDb.query(NicknameLookupQuery.TABLE, NicknameLookupQuery.COLUMNS,
                NicknameLookupColumns.NAME + "=?", new String[] { normalizedName },
                null, null, null);
        try {
            int count = cursor.getCount();
            if (count &gt; 0) {
                clusters = new String[count];
                for (int i = 0; i &lt; count; i++) {
                    cursor.moveToNext();
                    clusters[i] = cursor.getString(NicknameLookupQuery.CLUSTER);
                }
            }
        } finally {
            cursor.close();
        }
        return clusters;
    }
}
</code></pre>

<p>这个缓存类实现的实际上是一个二级缓存：</p>

<ol>
<li>第一级是一个BitSet，实现为一个hash表，它充当了一个过滤器的作用。第一次加载时会从db中查找所有的数据，并通过hash算法插入到表中的适当位置，这个过程和HashMap的实现是一样的，只不过没有处理hash冲突的情况，当出现hash冲突时，会覆盖表中原有的值。</li>
<li>第二级是一个HashMap，是真正的cache。其中的元素通过SoftReference引用。</li>
</ol>


<h3>Weak reference</h3>

<p>Weak reference和Soft reference类似，区别在于一旦GC启动，被Weak reference引用的对象就会被回收，而不管当前内存资源是否充裕，因此，被Weak reference引用的对象具有更短的生命周期。但是，由于gc是一个优先级比较低的进程，Weak reference的对象不会像你想象中那么快就被回收了。</p>

<h3>Phantom reference</h3>

<p>Phantom reference 和以上几种引用都不同。它的<code>get()</code>方法永远都会返回null。那么它究竟有什么作用呢？<br/>
TODO&hellip;</p>

<h3>References</h3>

<ul>
<li><a href="http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html">http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html</a></li>
<li><a href="http://improving.iteye.com/blog/436311">http://improving.iteye.com/blog/436311</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/12/differences-bt-noclassdeffounderror-and-classnotfoundexception/">NoClassDefFoundError 和 ClassNotFoundException 的区别</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-12T00:00:00+08:00" pubdate data-updated="true">Mar 12<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/12/differences-bt-noclassdeffounderror-and-classnotfoundexception/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/12/differences-bt-noclassdeffounderror-and-classnotfoundexception/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>先看API解释：<br/>
For ClassNotFoundException:</p>

<pre><code>Thrown when an application tries to load in a class through its string name using:

    * The forName method in class Class.
    * The findSystemClass method in class ClassLoader.
    * The loadClass method in class ClassLoader.

but no definition for the class with the specified name could be found.
</code></pre>

<p>For NoClassDefFoundError:</p>

<pre><code>Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.

The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.
</code></pre>

<p>简单的说，就是如果使用new SomeClass()的方式创建对象的，而这时ClassLoader装载SomeClass失败（可能因为权限不够，JNI错误,etc），就会抛出NoClassDefFoundError。<br/>
而如果使用反射来装载一个对象，但是SomeClass不在CLASSPATH中，这时就会抛出ClassNotFoundException。</p>

<p>Reference:<br/>
<a href="http://stackoverflow.com/questions/1457863/what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception">http://stackoverflow.com/questions/1457863/what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/02/my-first-post-on-git-pages/">使用Github Pages创建个人博客</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-02T00:00:00+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/02/my-first-post-on-git-pages/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/02/my-first-post-on-git-pages/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Github pages 是什么？</h2>

<p>Github pages借助 git 工具和Jekyll（一个静态网站生成器），使得你可以将内容push到github，然后通过Jekyll发布成个人blog站点。通过github pages创建个人博客，至少有几个好处：</p>

<ul>
<li>文章内容使用markdown标记语言书写，你可以使用任何你喜欢的文本编辑器编辑文章。</li>
<li>由于git的存在，你可以轻松的对你的文章进行版本控制。</li>
<li>尤其重要的一点，在天朝，你无需担心哪天你的站点被无端屏蔽，还得爬墙过去抢救数据&mdash;因为你本地就有一套完整的站点，而且都是文本格式，非常易于备份。</li>
</ul>


<h2>搭建步骤</h2>

<h3>创建github帐号</h3>

<p>首先，你需要一个github帐号。
登录github后，创建一个USERNAME.github.com的repository，根据向导生成pages。</p>

<h3>安装本地环境</h3>

<p>你需要在本地搭建运行环境，这样在编写文章的时候你可以在本地进行充分的调整，满意后再push到github。
以下基于Ubuntu 10.04LTS系统安装，需要安装的包包括Ruby，RubyGems，jekyll和rake。</p>

<pre><code>$ sudo apt-get install ruby1.9.1-full rubygems1.9.1
</code></pre>

<p>然后通过gem命令安装jekyll</p>

<pre><code>$ sudo gem install jekyll
WARNING:  You don't have /home/calvin/.gem/ruby/1.9.1/bin in your PATH,
      gem executables will not run.
ERROR:  Error installing jekyll:
    liquid requires RubyGems version &gt;= 1.3.7
</code></pre>

<p>安装会出错，提示RubyGems版本过低。这时候需要到<a href="http://packages.ubuntu.com/maverick/all/rubygems1.8/download">http://packages.ubuntu.com/maverick/all/rubygems1.8/download</a> 下载离线安装包安装：</p>

<pre><code>$ sudo dpkg -i Downloads/rubygems1.8_1.3.7-2_all.deb
</code></pre>

<p>安装完成后查看gem版本：</p>

<pre><code>$ which gem
/usr/bin/gem
$ gem -v
1.3.7
</code></pre>

<p>这时候可以继续安装jekyll了：</p>

<pre><code>$ sudo gem install jekyll
</code></pre>

<p>安装jekyll后还需要安装rake工具，通过rake工具可以用来创建新的文章和页面，安装主题等等，十分方便。</p>

<pre><code>$ sudo apt-get install rake
</code></pre>

<p>通过rake -T命令可以查看所有可用命令：</p>

<pre><code>$ rake -T
(in /home/calvin/development/github/calvinlee.github.com)
rake page           # Create a new page.
rake post           # Begin a new post in ./_posts
rake preview        # Launch preview environment
rake theme:install  # Install theme
rake theme:package  # Package theme
rake theme:switch   # Switch between Jekyll-bootstrap themes.
</code></pre>

<h3>安装Jekyll Bootstrap</h3>

<p>由于jekyll仅仅是一个静态html的生成器，它不包含任何页面的templates，所以如果从头开始构建你的博客站点的话，还将要有很多工作要做。幸好，<a href="http://jekyllbootstrap.com/">Jekyll Bootstrap</a>已经提供了一套基本的构架，我们只需要在它的基础上定制，使之符合你口味即可。</p>

<pre><code>$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com
$ cd USERNAME.github.com
$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git
$ git push origin master
</code></pre>

<h3>开始个性博客之旅</h3>

<p>首先在本地启动jekyll：</p>

<pre><code>$ /var/lib/gems/1.8/gems/jekyll-0.11.2/bin/jekyll --server
</code></pre>

<p>然后你可以访问<a href="http://localhost:4000%E6%9F%A5%E7%9C%8BJekyll">http://localhost:4000%E6%9F%A5%E7%9C%8BJekyll</a> Bootstrap给你提供了什么，之后你就可以开始写你的文章了。</p>

<pre><code>$ rake post title="my-first-post-on-git-pages" date="2012-03-02"
</code></pre>

<p>rake工具会为你生成posts/2012-03-02-my-first-post-on-git-pages.md
你可以开始使用markdown标记语言编辑文章了！</p>

<h3>发布</h3>

<p>发布很简单，直接将文章内容推送到github即可，如果你修改了页面主题或者布局，也一并推送：</p>

<pre><code>$ git add .
$ git commit -m "Add new post"
$ git push origin master
</code></pre>

<p>现在你就可以通过<a href="http://USERNAME.github.com%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82">http://USERNAME.github.com%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82</a></p>

<h3>Reference</h3>

<ul>
<li><a href="http://daringfireball.net/projects/markdown/syntax">详尽的Markdown语法</a></li>
<li><a href="http://www.pushiming.com/blog/2010/11/tips-on-markdown/">另外一篇Markdown简介</a></li>
<li><a href="https://github.com/mojombo/jekyll/wiki/">Jekyll wiki</a></li>
<li><a href="https://github.com/mojombo/jekyll/wiki/Sites">这里</a>是一些站点，有些是开放源代码的，你可以参照学习</li>
<li><a href="https://github.com/mojombo/jekyll/wiki/Pagination">怎样对文章进行分页？</a></li>
<li><a href="http://www.pizn.net/24-09-2011/use-github-pages-to-build-a-blog/">http://www.pizn.net/24-09-2011/use-github-pages-to-build-a-blog/</a></li>
<li><a href="http://www.yangzhiping.com/tech/writing-space.html">http://www.yangzhiping.com/tech/writing-space.html</a></li>
<li><a href="http://fastr.github.com/articles/Documenting-with-Jekyll.html">http://fastr.github.com/articles/Documenting-with-Jekyll.html</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/02/android-vold/">Android Vold 分析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-02T00:00:00+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/02/android-vold/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/02/android-vold/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Vold(Volume Daemon) 主要负责管理和控制外部存储设备，这些控制包括SD卡设备插拔，挂载，格式化等等.
Vold在Android 平台上的作用相当于udev在Linux平台上的功能。</p>

<h3>Vold的架构</h3>

<p>Vold的架构大致如图：</p>

<p><a href="/images/vold-architecture.png"><img src="/images/vold-architecture.png" alt="/images/vold-architecture.png" /></a></p>

<ul>
<li>Kernel：detect device hot-plug, load drivers</li>
<li>Sysfs: generate events and send it to user space</li>
<li>NetlinkManager: establish connection to sysfs, listen to uevents and process it</li>
<li>VolumeManager: disk volume operation</li>
<li>CommandListener:  wait for commands from MountService</li>
<li>NativeDaemonConnector:establish connection between MountService and vold daemon</li>
</ul>


<p>其中，一张SD卡对应一个DirectVolume对象。</p>

<p>Vold模块的类图如下：</p>

<p><a href="/images/vold-class-diagram.png"><img src="/images/vold-class-diagram.png" alt="/images/vold-class-diagram.png" /></a></p>

<h3>Vold startup</h3>

<p>vold的启动分为两个过程，一是vold daemon的启动，二是Java层MountService的启动。</p>

<h4>启动Vold daemon</h4>

<p>Vold daemon由init进程启动，参见init.rc片段：</p>

<p><a href="/images/vold-initrc.png"><img src="/images/vold-initrc.png" alt="/images/vold-initrc.png" /></a></p>

<p>vold入口函数位于/system/vold/mail.cpp，启动后处理流程如下：</p>

<p><a href="/images/vold-startup-sequence.png"><img src="/images/vold-startup-sequence.png" alt="/images/vold-startup-sequence.png" /></a></p>

<p>1.Create directory /dev/block/vold
1.Create singleton instance of VolumeManager , NetlinkManager  andCommandListener
1.Process configuration file /system/etc/vold.fstab
1.NetlinkManager creates connection between kernel and vold
1.Manually trigger uevents by writing “add\n” to file in /sys/block
1.CommandListener  starts listening commands from framework</p>

<h4>启动MountService</h4>

<p>1.MountService initialized by SystemServer on device starts up
1.Create connection to vold</p>

<p>After MountService is up, the vold system is ready.</p>

<h3>Send commands from framework</h3>

<p>以App层通过MountService 挂载一个volume为例，说明从上层向下层的调用流程。</p>

<p><a href="/images/vold-send-commands-from-framework.png"><img src="/images/vold-send-commands-from-framework.png" alt="/images/vold-send-commands-from-framework.png" /></a></p>

<ol>
<li>NativeDaemonConnector::sendCommand()</li>
<li>SocketListener::runListener() <code>&lt;</code>&mdash;vold accepting connections here</li>
<li>FrameworkListener::onDataAvailable()</li>
<li>FrameworkListener::dispatchCommand()</li>
<li>FrameworkCommand::runCommand()&mdash;-CommandListener::VolumeCmd::runCommand()</li>
<li>VolumeManager::mountVolume()</li>
<li>Volume::mountVol()</li>
</ol>


<h3>Process events from kernel</h3>

<p>处理kernel发出的挂载事件：</p>

<p><a href="/images/vold-process-events-from-kernel.png"><img src="/images/vold-process-events-from-kernel.png" alt="/images/vold-process-events-from-kernel.png" /></a></p>

<ol>
<li>SocketListener::runListener <code>&lt;</code>&mdash;listening events from kernel</li>
<li>NetlinkListener::onDataAvailable()</li>
<li>NetlinkHandler::onEvent()</li>
<li>VolumeManager::handleBlockEvent , VolumeManager::handleSwitchEvent , VolumeManager::handleUsbCompositeEvent</li>
<li>DirectVolume::handleBlockEvent()</li>
<li>DirectVolume::handleDiskAdded, DirectVolume::handlePartitionAdded, DirectVolume::handleDiskRemoved, DirectVolume::handlePartitionRemoved,DirectVolume::handleDiskChanged, DirectVolume::handlePartitionChanged,or ignore non add/remove/change event</li>
</ol>


<h3>Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/qianjin0703/article/details/6362389">http://blog.csdn.net/qianjin0703/article/details/6362389</a></li>
<li><a href="http://www.cnblogs.com/iceocean/articles/1594195.html">http://www.cnblogs.com/iceocean/articles/1594195.html</a></li>
<li><a href="http://www.chinaunix.net/jh/4/822500.html">http://www.chinaunix.net/jh/4/822500.html</a></li>
<li><a href="http://blog.csdn.net/fudan_abc/article/details/1768277">http://blog.csdn.net/fudan_abc/article/details/1768277</a></li>
<li><a href="http://dongyulong.blog.51cto.com/1451604/389159">http://dongyulong.blog.51cto.com/1451604/389159</a></li>
<li><a href="http://blog.csdn.net/datangsoc/article/details/5928132">http://blog.csdn.net/datangsoc/article/details/5928132</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/18/install-wireless-driver-on-ubuntu-1004/">Ubuntu10.04安装无线网卡ath9k_htc驱动</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-18T00:00:00+08:00" pubdate data-updated="true">Oct 18<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/10/18/install-wireless-driver-on-ubuntu-1004/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2011/10/18/install-wireless-driver-on-ubuntu-1004/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我的USB无线网卡型号为TL_WN721N，插在Ubuntu10.04上没有反应。据说10.10以后插上就可以用了，没有测试。</p>

<p>第一步 确定ath9k_htc驱动支持你的网卡型号<br/>
<a href="http://linuxwireless.org/en/users/Drivers/ath9k_htc/devices">这里</a> 列出了支持的型号列表，你可以通过lsusb查看自己的网卡型号是否在列表当中。</p>

<p>第二步 安装firmwire<br/>
从<a href="http://wireless.kernel.org/download/htc_fw/">这里</a>下载htc_9271.fw，拷贝到/lib/firmwire下</p>

<p>第三步 安装compact wireless<br/>
安装compact wireless有打包好的deb包，从这里下载GUI Program to install ath9k_htc，安装完后直接运行，等待安装完成重启机器就可以了。
爱折腾的也可以到<a href="http://wireless.kernel.org/download/">这里</a>下载
最新的compact wireless驱动，然后编译安装：</p>

<pre><code>sudo make
sudo make install
sudo make unload
sudo make load ath9k_htc
</code></pre>

<p>重启机器即可。</p>

<p>Reference
* <a href="http://forum.ubuntu.com.cn/viewtopic.php?f=116&amp;t=326568&amp;p=2388841">http://forum.ubuntu.com.cn/viewtopic.php?f=116&amp;t=326568&amp;p=2388841</a>
* <a href="http://blog.chinaunix.net/space.php?uid=20620288&amp;do=blog&amp;id=2691282">http://blog.chinaunix.net/space.php?uid=20620288&amp;do=blog&amp;id=2691282</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/06/compile-cyanogenmod-for-htc-desire/">Compile CyanogenMod (Linux) for HTC Desire</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-06T00:00:00+08:00" pubdate data-updated="true">Sep 6<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/09/06/compile-cyanogenmod-for-htc-desire/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2011/09/06/compile-cyanogenmod-for-htc-desire/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>出现如下问题：<br/>
1.repo init时报错：</p>

<pre><code>......
object 30d452905f166b316152f236422f85c8aa75a2d0
type commit
tag v1.7.5
tagger Shawn O. Pearce &lt;sop@google.com&gt; 1307663540 -0700

repo 1.7.5

gpg: Signature made Fri 10 Jun 2011 07:52:20 AM CST using DSA key ID 920F5C65
gpg: Can't check signature: public key not found
error: could not verify the tag 'v1.7.5'
</code></pre>

<p>出错原因是曾使用repo sync从其它库sync过代码，删掉~/.repoconfig即可：</p>

<pre><code>$ rm -rf ~/.repoconfig
$ ./repo init -u git://github.com/CyanogenMod/android.git -b gingerbread
gpg: keyring `/home/calvin/.repoconfig/gnupg/secring.gpg' created
gpg: keyring `/home/calvin/.repoconfig/gnupg/pubring.gpg' created
gpg: /home/calvin/.repoconfig/gnupg/trustdb.gpg: trustdb created
gpg: key 920F5C65: public key "Repo Maintainer &lt;repo@android.kernel.org&gt;" imported
gpg: Total number processed: 1
gpg:               imported: 1

Getting repo ...
   from http://android.git.kernel.org/tools/repo.git
。。。。
</code></pre>

<p>2.repo sync时报错：</p>

<pre><code>......
Fetching projects:   1% (3/285) 
Initializing project platform/bootable/bootloader/legacy ...
android.git.kernel.org[0: 130.239.17.13]: errno=Connection refused
android.git.kernel.org[0: 149.20.4.77]: errno=Connection timed out
android.git.kernel.org[0: 199.6.1.173]: errno=Connection refused
android.git.kernel.org[0: 2001:4f8:8:10:1972:112:1:0]: errno=Network is unreachable
android.git.kernel.org[0: 2001:500:60:10:1972:112:1:0]: errno=Network is unreachable
android.git.kernel.org[0: 2001:6b0:e:4017:1972:112:1:0]: errno=Network is unreachable
android.git.kernel.org[0: 2001:4f8:1:10:1972:112:1:0]: errno=Network is unreachable
fatal: unable to connect a socket (Network is unreachable)
error: Cannot fetch platform/bootable/bootloader/legacy
</code></pre>

<p>连接服务器时的问题，解决：<br/>
修改.repo/manifest.xml中</p>

<pre><code>  &lt;remote  name="korg"
           fetch="git://android.git.kernel.org/"
           review="review.source.android.com" /&gt;
</code></pre>

<p>为</p>

<pre><code>  &lt;remote  name="korg"
           fetch="http://android.git.kernel.org/"
           review="review.source.android.com" /&gt;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/07/android-monkey-jni-issues/">Android Monkey & Jni相关</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-05-07T00:00:00+08:00" pubdate data-updated="true">May 7<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/05/07/android-monkey-jni-issues/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2011/05/07/android-monkey-jni-issues/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先，android平台应用程序可能产生以下四种crash：
* App层： Force close crash 和 ANR crash
* Native层： Tombstone crash
* Kernel层： Kernel panic 比较难定位，可以查看/proc/last_kmsg来辅助定位。</p>

<p>最近需要通过monkey工具测试Tombstone类型的crash，抓取log并分析。通过monkey测试，如果要抓取native类型的crash，需要加上&mdash;monitor-native-crash参数：</p>

<pre><code>seed=$(date +%Y%m%d%H%m%S)
monkey -s $seed --pkg-whitelist-file ${your-package-list} --monitor-native-crashes --kill-process-after-error -v -v -v 2000000000
</code></pre>

<p>这样，monkey在跑出crash后，在/data/system/dropbox 和 /data/tombstones目录下会生成相关日志，moneky会停止发送事件流并退出测试.值得注意的是，/data/tombstones文件夹下只会保存10个日志，超过10个后，最早创建的会被替换。而monkey是通过监视这个文件夹下的文件数量变化来判断是否有tombtone类型的crash产生的。因此，当/data/tombstones文件夹下超过10个文件后，如果再有tombstone crash产生的话，monkey是不能检测到的，它会继续发送事件流。为了避免这个问题，可以在每次运行monkey之前先清空一下这个文件夹。</p>

<p>另外，在settings.db中的secure表中有三个字段：dropbox:data_app_wtf,dropbox:data_app_anr,dropbox:data_app_crash。如果设置为enabled，每当有app crash之后，在/data/system/dropbox这个文件夹下都会产生相关的日志信息，这对于分析调试问题都是第一手的信息。</p>

<h3>如何制造tombstone类型的crash？</h3>

<p>这需要通过jni调用一个native的so文件，在本地代码中抛出异常即可。
可以编写如下代码tombstone_gen.cpp:</p>

<pre><code>int main(int argc, char **argv) {
  int *p=0;
  *p=1;    //will seg fault
  return 0;
}
</code></pre>

<p>参照development/samples/SimpleJNI的示例，运行build出的apk即可。</p>

<p>关于jni调用，也有几个问题：</p>

<p>1.FindClass,RegisterNatives等找不到：</p>

<pre><code>    target thumb C: libtombstonec &lt;= development/samples/AndroidDemos/jni/tombstone_gen.c
    development/samples/AndroidDemos/jni/tombstone_gen.c: In function 'registerNativeMethods':
    development/samples/AndroidDemos/jni/tombstone_gen.c:48: error: request for member 'FindClass' in something not a structure or union
    development/samples/AndroidDemos/jni/tombstone_gen.c:53: error: request for member 'RegisterNatives' in something not a structure or union
    development/samples/AndroidDemos/jni/tombstone_gen.c: In function 'JNI_OnLoad':
    development/samples/AndroidDemos/jni/tombstone_gen.c:97: error: request for member 'GetEnv' in something not a structure or union
    make: *** [out/target/product/generic/obj/SHARED_LIBRARIES/libtombstonec_intermediates/tombstone_gen.o] Error 1

问题原因在于：  
如果是C程序，要用`(*env)-&gt;`  
如果是C++要用 `env-&gt;`  
因此有两种解决方法：  
* 将 (*env)-&gt; 改为 env-&gt;  
* 将c文件改为cpp文件，改为c++的方式编译。  
</code></pre>

<p>2.运行时异常java.lang.UnsatisfiedLinkError</p>

<pre><code>tombstone_gen.cpp中

    static const char *classPathName = "com/android/demo/AndroidDemos";

类名有误，导致类链接错误。
</code></pre>

<p>最后，关于jni中JNINativeMethod相关解释：<br/>
<a href="http://hi.baidu.com/zhlg_hzh/blog/item/f0d782081f2f45d963d986f5.html">http://hi.baidu.com/zhlg_hzh/blog/item/f0d782081f2f45d963d986f5.html</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/7/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/5/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>Android (12)</a></li>
<li class='category'><a href='/blog/categories/c-/'>C++ (1)</a></li>
<li class='category'><a href='/blog/categories/c语言/'>C语言 (5)</a></li>
<li class='category'><a href='/blog/categories/eclipse/'>Eclipse (2)</a></li>
<li class='category'><a href='/blog/categories/git/'>Git (3)</a></li>
<li class='category'><a href='/blog/categories/http/'>HTTP (1)</a></li>
<li class='category'><a href='/blog/categories/http/'>Http (1)</a></li>
<li class='category'><a href='/blog/categories/java/'>Java (5)</a></li>
<li class='category'><a href='/blog/categories/kindle/'>Kindle (1)</a></li>
<li class='category'><a href='/blog/categories/linux/'>Linux (10)</a></li>
<li class='category'><a href='/blog/categories/shell/'>Shell (1)</a></li>
<li class='category'><a href='/blog/categories/vim/'>Vim (1)</a></li>
<li class='category'><a href='/blog/categories/chromium/'>chromium (1)</a></li>
<li class='category'><a href='/blog/categories/设计模式/'>设计模式 (1)</a></li>
<li class='category'><a href='/blog/categories/读书笔记/'>读书笔记 (3)</a></li>

  </ul>
</section>

<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 90%" href="/tags/c-plus-plus/">C++</a>
<a style="font-size: 156%" href="/tags/cyu-yan/">C语言</a>
<a style="font-size: 210%" href="/tags/android/">android</a>
<a style="font-size: 118%" href="/tags/archlinux/">archlinux</a>
<a style="font-size: 90%" href="/tags/awk/">awk</a>
<a style="font-size: 90%" href="/tags/c/">c</a>
<a style="font-size: 90%" href="/tags/c-plus-plus/">c++</a>
<a style="font-size: 118%" href="/tags/csapp/">csapp</a>
<a style="font-size: 90%" href="/tags/debug/">debug</a>
<a style="font-size: 118%" href="/tags/eclipse/">eclipse</a>
<a style="font-size: 90%" href="/tags/gcc/">gcc</a>
<a style="font-size: 135%" href="/tags/git/">git</a>
<a style="font-size: 90%" href="/tags/github/">github</a>
<a style="font-size: 90%" href="/tags/graphics/">graphics</a>
<a style="font-size: 118%" href="/tags/http/">http</a>
<a style="font-size: 156%" href="/tags/java/">java</a>
<a style="font-size: 90%" href="/tags/kernel/">kernel</a>
<a style="font-size: 90%" href="/tags/kindle/">kindle</a>
<a style="font-size: 175%" href="/tags/linux/">linux</a>
<a style="font-size: 90%" href="/tags/permission/">permission</a>
<a style="font-size: 90%" href="/tags/php/">php</a>
<a style="font-size: 90%" href="/tags/proxy/">proxy</a>
<a style="font-size: 90%" href="/tags/shell/">shell</a>
<a style="font-size: 90%" href="/tags/socket/">socket</a>
<a style="font-size: 163%" href="/tags/todo/">todo</a>
<a style="font-size: 135%" href="/tags/vim/">vim</a>
<a style="font-size: 90%" href="/tags/window/">window</a>
<a style="font-size: 169%" href="/tags/ming-ling/">命令</a>
<a style="font-size: 90%" href="/tags/she-ji-mo-shi/">设计模式</a>
<a style="font-size: 118%" href="/tags/zhuan-zai/">转载</a>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/11/07/awesome-bind-mount/">Bind Mount的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/04/disable-kernel-random-address/">禁用内核进程地址随机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/26/Chrominum-base-code-introduction/">Chromium Base库介绍</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/25/strcpy-memcpy/">Strcpy和memcpy的区别</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/28/eclipse-debug-break-points/">Eclipse 调试中的五种断点</a>
      </li>
    
  </ul>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Calvin Lee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'calvin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
