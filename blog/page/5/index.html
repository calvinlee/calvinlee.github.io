
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>且听风吟</title>
  <meta name="author" content="Calvin Lee">

  
  <meta name="description" content="
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://calvinlee.github.io/blog/page/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="且听风吟" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">且听风吟</a></h1>
  
    <h2>Don't panic! I'm a programmer.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:calvinlee.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/links.html">Links</a></li>
  <li><a href="/music.html">Music</a></li>
  <li><a href="/about.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/13/csapp-machine-level-representation-of-c-programs/">CSAPP读书笔记-程序的机器级表示</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-13T00:00:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/04/13/csapp-machine-level-representation-of-c-programs/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/04/13/csapp-machine-level-representation-of-c-programs/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/10/x86-registers/">X86 平台寄存器概述</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/04/10/x86-registers/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/04/10/x86-registers/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>32位机器</h3>

<h3>64位机器</h3>

<h3>为什么寄存器的数量不是多多益善？</h3>

<p><a href="http://bbs.pediy.com/archive/index.php?t-78354.html">http://bbs.pediy.com/archive/index.php?t-78354.html</a>
<a href="http://www.cppblog.com/lingjingqiu/archive/2009/12/10/102874.html">http://www.cppblog.com/lingjingqiu/archive/2009/12/10/102874.html</a>
<a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">http://www.cs.virginia.edu/~evans/cs216/guides/x86.html</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/10/is-char-signed-or-unsigned/">Char类型是有符号的还是无符号的？</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/04/10/is-char-signed-or-unsigned/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/04/10/is-char-signed-or-unsigned/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://ihacklog.com/programming/c/char-is-signed-or-unsigned-by-default.html">http://ihacklog.com/programming/c/char-is-signed-or-unsigned-by-default.html</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/05/interesting-c-code-snippets/">一些有趣的C程序</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-05T00:00:00+08:00" pubdate data-updated="true">Apr 5<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/04/05/interesting-c-code-snippets/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/04/05/interesting-c-code-snippets/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><pre><code>#include &lt;stdio.h&gt;

int n[]={0x48,0x65,0x6C,0x6C, 
0x6F,0x2C,0x20, 
0x77,0x6F,0x72, 
0x6C,0x64,0x21, 
0x0A,0x00},\*m=n;

main(n){ 
    if(putchar (\*m)!='\0') main(m++);
}
</code></pre>

<p>输出<code>Hello, world!</code></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/04/kindle-related-resources/">Kindle Keyboard 资源索引</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-04T00:00:00+08:00" pubdate data-updated="true">Apr 4<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/04/04/kindle-related-resources/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/04/04/kindle-related-resources/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="/images/amazon_kindle_wifi_3rd_generation.jpg"><img src="/images/amazon_kindle_wifi_3rd_generation.jpg" alt="/images/amazon_kindle_wifi_3rd_generation.jpg" /></a></p>

<h3>越狱</h3>

<p>下载 <a href="http://www.mobileread.com/forums/showthread.php?t=88004">update-jailbreak-*.zip</a>，并解压出对应你的机器的版本的 update_jailbreak_*_install.bin 文件，放到 Kindle 的根目录中，然后在 Kindle 的 Settings 页面中，按 Menu，选择 Update your Kindle，等待两分钟左右，即可完成越狱，并且由于已经重启了，这时 Kindle 的根目录中应该已经多出了 linkjail 这个目录了。在 Kindle 的内部文件系统中，相应的目录已经被换成了符号链接，目标就是这个 linkjail，我们可以通过修改 linkjail 中的文件来达到修改 Kindle 内部文件系统文件的目的。</p>

<h3>中文字体优化</h3>

<ul>
<li><a href="http://wzyboy.im/post/736.html">Kindle 中文阅读终极优化指南</a></li>
<li><a href="http://www.kdolphin.com/1204">Kindle 3的字体、行距、边距</a></li>
<li><a href="http://irising.me/2011/06/4986/">Kindle 3 安装中文输入法</a></li>
</ul>


<h3>电子书资源</h3>

<ul>
<li><a href="http://www.douban.com/group/topic/22560203/">http://www.douban.com/group/topic/22560203/</a></li>
<li><a href="http://book.zi5.me/">子乌书简</a></li>
<li><a href="http://ikindle.mobi/book/">ikindle万卷书</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/31/connect-2-android-emulator-instance/">Android模拟器与host主机以及模拟器之间进行TCP通信</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-31T00:00:00+08:00" pubdate data-updated="true">Mar 31<span>st</span>, 2012</time>
        
           | <a href="/blog/2012/03/31/connect-2-android-emulator-instance/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/31/connect-2-android-emulator-instance/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>QEMU Networking</h3>

<p>Android 模拟器基于QEMU虚拟机构建，虚拟机（guest）与所在的PC主机（host）之间的网络通信有几种方式：</p>

<ol>
<li><p>NAT方式<br/>
  Android模拟器的网络连接使用NAT方式。<br/>
 这种方式通过host机器的网络接口访问网络，优点是方便设置，不用创建额外的网络接口。缺点是guest可以访问外部网络，但是反过来host不能访问到guest。Android通过端口转发解决这一问题。<br/>
 NAT网络结构如下所示(图片来自<a href="http://wiki.qemu.org/Documentation/Networking">qumu wiki</a>)：</p>

<p> <a href="/images/qemu_Slirp_concept.png"><img src="/images/qemu_Slirp_concept.png" alt="/images/qemu_Slirp_concept.png" /></a></p>

<p> 由此可见，guest与host不在同一个网段，guest通过10.0.2.2访问host机器.</p></li>
<li>Bridge方式</li>
</ol>


<h3>模拟器与host通信</h3>

<p>启动模拟器，adb server会在5554端口上监听来自adb client的连接，我们可以通过这个端口与模拟器通信。<br/>
在模拟器上运行如下服务器程序，在<strong>模拟器</strong>的8000端口上监听客户端连接，接收到客户端连接后，发送一段echo字符串，然后关闭连接：</p>

<pre><code>public class EmulatorServerActivity extends Activity {
    private ServerSocket serverSocket = null;

    public static final int SERVERPORT = 8000;

    private boolean keepRunning = false;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        keepRunning = true;
        new Thread(new ServerThread()).start();
    }

    @Override
    protected void onStop() {
        super.onStop();
        try {
            keepRunning = false;
            serverSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    class ServerThread implements Runnable {
        public void run() {
            try {
                serverSocket = new ServerSocket(SERVERPORT);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            while (keepRunning) {
                try {
                    Log.d("Server", "Wating for connection...");
                    Socket s = serverSocket.accept();
                    BufferedReader reader = new BufferedReader(new InputStreamReader(
                            s.getInputStream()));
                    String msg = reader.readLine();
                    Log.d("Server", "Received message from client:" + msg);
                    String echo = "You are telling me: " + msg + ", bye\n";
                    s.getOutputStream().write(echo.getBytes());
                    s.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>

<p>在host机器上通过telnet连接到模拟器：</p>

<pre><code>telnet localhost 5554
</code></pre>

<p>然后设置端口转发：</p>

<pre><code>redir add tcp:7777:8000
redir list // 显示已添加的端口转发
exit
</code></pre>

<p>添加端口转发命令格式为：</p>

<pre><code>redir add &lt;protocol&gt;:&lt;host-port&gt;:&lt;guest-port&gt;
</code></pre>

<p>其中，protocol必须是tcp或udp，host-port是主机上开启的端口号，guest-port 是模拟器的监听端口号。</p>

<p>这条端口转发命令表示将发送到host机器的7777端口的所有tcp数据转发到guest机器的8000端口，也就是我们的server程序监听的端口，这个过程对client来说是完全透明的，它只知道它把数据发送到host的7777端口，它对数据如何转发一无所知。这时在host机器上可以看到7777端口已经处于监听状态：</p>

<pre><code>$ netstat -tln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 127.0.0.1:7777          0.0.0.0:*               LISTEN 
</code></pre>

<p>通过设置端口转发，host机器就可以通过这个7777端口连接guest机器上的服务程序了：</p>

<pre><code>$ telnet localhost 7777
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
hello
You are telling me: hello, bye
Connection closed by foreign host.
</code></pre>

<h3>模拟器之间通信</h3>

<p>启动另一个模拟器，运行客户端程序：</p>

<pre><code>public class EmulatorClientActivity extends Activity {
    private String serverIpAddress = "10.0.2.2";

    // 注意：我们需要连接host机器的7777端口
    private static final int REDIRECTED_SERVERPORT = 7777;

    private Socket socket;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        new Thread(new CommsThread()).start();
    }

    class CommsThread implements Runnable {
        public void run() {
            try {
                InetAddress serverAddr = InetAddress.getByName(serverIpAddress);
                socket = new Socket(serverAddr, REDIRECTED_SERVERPORT);
                socket.getOutputStream().write(new String("Hello\n").getBytes());
                Log.d("Client", "Message sent to server");
                socket.close();
            } catch (UnknownHostException e1) {
                e1.printStackTrace();
            } catch (IOException e1) {
                e1.printStackTrace();
            }
        }
    }
}
</code></pre>

<p>注意：在这个客户端程序里，我们需要连接的socket为10.0.2.2:7777,其中，10.0.2.2是host机器的ip地址，发送到host机器的7777端口的数据会被透明的转发到另一个模拟器的8000端口上，这样，连接就建立起来了。</p>

<h3>Reference</h3>

<ul>
<li><a href="http://wiki.qemu.org/Documentation/Networking">http://wiki.qemu.org/Documentation/Networking</a></li>
<li><a href="http://www.virtualbox.org/manual/ch06.html#nat-limitations">http://www.virtualbox.org/manual/ch06.html#nat-limitations</a></li>
<li><a href="http://felipec.wordpress.com/2009/12/27/setting-up-qemu-with-a-nat/">http://felipec.wordpress.com/2009/12/27/setting-up-qemu-with-a-nat/</a></li>
<li><a href="http://www.cnblogs.com/yangnas/archive/2010/05/28/1745917.html">http://www.cnblogs.com/yangnas/archive/2010/05/28/1745917.html</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/26/git-tips/">Git Tips</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-26T00:00:00+08:00" pubdate data-updated="true">Mar 26<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/26/git-tips/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/26/git-tips/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>配置</h3>

<ul>
<li><p>git alias</p>

<p>  git config &mdash;global alias.co checkout<br/>
  git config &mdash;global alias.br branch<br/>
  git config &mdash;global alias.ci commit<br/>
  git config &mdash;global alias.st status<br/>
  &hellip; &hellip;</p></li>
</ul>


<h3>查看历史</h3>

<ul>
<li><p>git log</p>

<p>-N                 只显示最近N次提交<br/>
-p                 按补丁格式显示每个更新之间的差异。<br/>
&mdash;stat             显示每次更新的文件修改统计信息。<br/>
&mdash;shortstat        只显示&mdash;stat中最后的行数修改添加移除统计。<br/>
&mdash;name-only        仅在提交信息后显示已修改的文件清单。<br/>
&mdash;name-status      显示新增、修改、删除的文件清单。<br/>
&mdash;relative-date    使用较短的相对时间显示（比如，“2 weeks ago”）。<br/>
&mdash;graph            显示 ASCII 图形表示的分支合并历史。<br/>
&mdash;pretty           使用其他格式显示历史提交信息。可用的选项包括oneline，short，full，fuller和format（后跟指定格式）。<br/>
&mdash;since,&mdash;after    仅显示指定时间之后的提交。<br/>
&mdash;until,&mdash;before   仅显示指定时间之前的提交。<br/>
&mdash;author           仅显示指定作者相关的提交。<br/>
&mdash;committer        仅显示指定提交者相关的提交。</p>

<p><code>git log --stat</code><br/>
查看每次提交修改的代码行数</p>

<p><code>git log --name-status  --author=bob --pretty=format:</code> // 注意format为空
统计bob改动的文件列表，可以将结果保存为文本文件，用vim打开，使用<code>:sort u</code>删去重复的行</p>

<p><code>git instaweb</code> 以web的方式查看仓库<br/>
<code>git instaweb --stop</code> 停止服务器</p></li>
</ul>


<h3>撤销回滚</h3>

<ul>
<li><p>git reset</p>

<ol>
<li> git reset &mdash;soft 只撤销 commit,保留 working tree 和 index file。</li>
<li> git reset &mdash;hard 撤销 commit、index file 和 working tree,即彻底销毁最近一次的 commit</li>
<li> git reset &mdash;mixed 撤销 commit 和 index file,保留 working tree</li>
<li> git reset 和 git reset &mdash;mixed 完全一样</li>
<li> git reset &mdash;用于删除登记在 index file 里的某个文件。</li>
</ol>


<p>  git reset的第二种用法: <br/>
  <code>git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...</code>
  将指定路径的文件在commit的内容拷贝到暂存区。git reset path和git add path效果相反。</p></li>
<li><p>回退版本(参考<a href="http://hi.baidu.com/talltwintowers/blog/item/36c931bf7685360119d81fc6.html">这里</a>)</p>

<p>回退版本很简单，<code>git checkout sha1</code> 即可。<br/>
现在你不在任何一个branch（no branch），执行git status显示：</p>

<pre><code>  $ git status
  # Not currently on any branch.
  nothing to commit (working directory clean)
</code></pre>

<p>  这个操作会将HEAD指向指定commit,并重置index和working tree到此commit的状态. 但由于此commit不是任何branch的头(&ldquo;head&rdquo; or &ldquo;tip&rdquo;),所以git会给出警告.这种情况称为&#8221;HEAD is detached&#8221;.参考<a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#detached-head">这里</a><br/>
  虽然警告,但并没有什么危险,只要别做commit,最后checkout回(某个branch)来就行了.<br/>
  如果此时做commit呢?&mdash;那也没有什么,只是这个新的commit以后只能通过SHA1来引用了(当然,还可以用git reflog看到),好比一个野指针;或者你赋个tag给它.不过这没有意义,如果你真的想从这儿发展下去,那么应该新建一个branch,比如<code>git checkout -b &lt;new_branch&gt; &lt;start_point&gt;</code><br/>
  但是注意,做此操作时working tree和index应该是&#8221;干净的&#8221;,就是和HEAD(所指的commit)完全一致,没有任何改动,否则git会报错不执行;你可能会看到类似这样的error:</p>

<pre><code>  error: You have local changes to 'somefile'; cannot switch branches.或
  error: Entry 'somefile' would be overwritten by merge. Cannot merge.
</code></pre>

<p>  (不过,你可以用&mdash;merge选项强制执行,此时git会做一个three-way merge)</p>

<p>  要切换回HEAD commit,执行<code>git checkout branch-name</code></p></li>
</ul>


<h3>Diff &amp; Patch</h3>

<ul>
<li><p>git diff</p>

<pre><code>git diff 查看 working tree 与 index file 的差别。  
git diff --cached/--staged 查看 index file 与最后一次提交的commit之间的差别的。  
git diff HEAD 是查看 working tree 和最后一次提交的commit之间的差别的。  
</code></pre></li>
<li><pre><code>git format-patch -1    生成最后一个提交对应的patch文件
git am &lt; diff.patch    把一个patch文件应用到当前分支
</code></pre></li>
</ul>


<h3>Branch</h3>

<ul>
<li>所谓Branch，本质上是一个指针（一串SHA号），指向某个commit。特别的，HEAD是当前分支的最后一个commit的别名。</li>
<li><p>git merge
  多个分支进行merge时可能存在两种方式：</p>

<ol>
<li> Fast-forward</li>
<li> 两个分支（A，B）的末端和这两个分支的共同祖先（C）进行三方合并（可能出现冲突），合并后将产生一个新的commit，这个commit有两个祖先（A和B）。</li>
</ol>


<p>  <code>git branch --merged</code> 查看有哪些分支已经合并进当前分支了，这些分支可以删掉了，因为这些分支的更改已经包含再当前分支里面了<br/>
  <code>git branch --no-merged</code> 查看尚未合并的分支</p></li>
<li><p>git rebase
                   A&mdash;-B&mdash;-C topic
                  /
             D&mdash;-E&mdash;-F&mdash;-G master
当前分支为topic，<code>git rebase master</code>，rebase的过程是：</p>

<ol>
<li>把从topic和master共同的祖先E开始在当前分支上的提交生成一个patch文件</li>
<li>将A、B、C砍掉，相当与执行<code>git reset --hard master</code></li>
<li>将生成的patch文件一个一个应用到G上</li>
</ol>


<p>结果变成这样：
                           A&#8217;&mdash;B&#8217;&mdash;C&#8217; topic
                          /
             D&mdash;-E&mdash;-F&mdash;-G master
topic的提交历史被改写了，成了master分支的直接下游，这时在master分支上做一次fast-forward的merge就好了。</p>

<p>可见，相比于merge，rebase不会产生一个新的commit，合并后的主线更加干净。如果希望在执行git pull时自动使用git rebase取代默认的git merge操作，可以执行</p>

<pre><code>git pull --rebase
</code></pre>

<p>参见<a href="http://www.worldhello.net/gotgithub/04-work-with-others/020-shared-repo.html#rebase-and-push">这里</a></p></li>
<li><p>git pull</p>

<p>  git pull = git fetch + git merge<br/>
  git pull origin next = git fetch origin/next + git merge origin/next  // 将远程分支next合并到当前分支上</p>

<p><code>git pull</code>会把所有正在跟踪远端仓库的分支的本地分支进行数据拉取。
执行git pull, git merge, git reset之前的HEAD会被保存到ORIG_HEAD,所以如果要回滚刚才的pull动作，那么执行<code>git reset --hard ORIG_HEAD</code>。查看pull下来的内容，执行<code>git diff ORIG_HEAD</code></p></li>
<li><p>git push</p>

<p><code>git push origin featureA</code> 将本地的featureA分支推送到远程仓库<br/>
<code>git push origin local_branch:remote_branch</code> 将本地的local_branch的内容推送到origin远程仓库的remote_branch分支上去，所以执行 <code>git push origin :remote_branch</code> 将删除远程版本库的 remote_branch 分支。</p></li>
<li><p>git fetch</p>

<pre><code>$ git remote add rc git@github.com:calvinlee/git-sandbox.git
$ git remote -v
origin    git@github.com:calvinlee/git-sandbox.git (fetch)
origin    git@github.com:calvinlee/git-sandbox.git (push)
rc    git@github.com:calvinlee/git-sandbox.git (fetch)
rc    git@github.com:calvinlee/git-sandbox.git (push)
$ git fetch rc
 * [new branch]      experimental -&gt; rc/experimental
 * [new branch]      master     -&gt; rc/master
</code></pre>

<p>运行git fetch后，本地多了从rc这个库fetch下来的分支：</p>

<pre><code>$ git branch -r
origin/HEAD -&gt; origin/master
origin/experimental
origin/master
rc/experimental
rc/master
</code></pre>

<p>现在可以切换到这个分支查看，或者选择merge到本地分支。（远程分支以这样的形式命名：远程仓库名/分支名）</p></li>
</ul>


<h3>git reset与git checkout</h3>

<p><code>git reset</code>用来修改refs的指向:修改的是.git/refs/heads/master的值，HEAD本身一直指向refs/heads/master, 并没有在reset过程中改变。
<code>git checkout</code>用来修改HEAD的指向: 修改的是.git/HEAD的文件内容, checkout不影响.git/refs/heads/下文件的内容。</p>

<p>什么叫detached HEAD？<br/>
这个状态下.git/HEAD指向了一个具体的commit ID，而不是一个分支的名称。</p>

<h3>符号</h3>

<ul>
<li><p>branchA..branchB</p>

<p>用来获取在branchB上但是不在branchA上的提交。如：<br/>
<code>git log --pretty=format:"%h %s" HEAD~3..HEAD</code> 显示最近三次提交的log<br/>
<code>git log origin/master..HEAD</code> 显示所有在当前分支上但不在远程分支上的提交。如果当前分支正在track远程分支，那么下次运行<code>git push</code>将推送这些提交到远程分支上。</p>

<p>这种表示法与下列语法等价：</p>

<pre><code> ^branchA branchB
 branchB --not branchA
</code></pre></li>
<li><p>branchA&hellip;branchB</p>

<p>获取被两个分支之一包含但不被这两个分支同时包含的提交。</p></li>
<li><p>^[N] 和 ~[N]</p>

<p>两个分支合并后，你合并时所在分支称为first parent，你所合并的分支称为second parent<br/>
HEAD^[N]表示HEAD的第N个second parent<br/>
HEAD~[N]表示HEAD的第N个first parent</p></li>
<li><p>获取某一次特定提交对应的文件内容
e43fef:path/to/file<br/>
获取暂存区中的文件对象：<br/>
:path/to/file</p></li>
</ul>


<h3>其它</h3>

<ul>
<li><p>将多个commit合成一个commit后提交</p>

<p>场景：<br/>
packages/apps/Email 已经提交了多个commit在branchA上，现在要把这些commit压成一个commit合并到merge_fix分支上。</p>

<pre><code> $ cd packages/apps/Email
 $ repo sync .
 $ git log --pretty=oneline // 假如需要squash commit1 和 commit2
   e8949d30bcb568b32a12338a28fb9d7a13e8b086 commit1
   6d7eef22cd2634bd0da8de8e38635dd92b3e5a48 commit2
   0130c5a03756b01ec4a39422ab08474625153a81 commit3
 $ git rebase -i 0130c5a03756b01ec4a39422ab08474625153a81 //注意这里是想要squash的commit的前一个commit(commit3), 更改commit message后继续
 $ git log -2 //找到squash后的commit，假如squash后的commit号为bed1b4fa7ae3f9a4a546f2aa367a8f2e7ba4b7b1
 $ git checkout merge_fix
 $ git cherry-pick bed1b4fa7ae3f9a4a546f2aa367a8f2e7ba4b7b1
</code></pre>

<p>  完毕</p></li>
<li><p>一个图片文件 index.jpeg 冲突了，如何取出他人的版本?</p>

<pre><code>git show :3:./index.jpeg &gt; index.jpeg-theirs
</code></pre>

<p>可以先使用git ls-files查看：</p>

<pre><code>$ git ls-files -s
100644 a97de6ee1b2352f4e33d09196fa478ffaae0b024 0 README
100644 04c14c2023f69123e719fae7c4242537c943b726 0 file1
100644 2f08be9a02925b5c016904e19fbd5e8d057ae756 0 hello.c
100644 eb651d4b863843d3ad12c446b541075f2839d7d2 2 index.jpeg
100644 099df17855c924472b1809d99389d8eee7582d9f 3 index.jpeg
</code></pre>

<p>第三栏称为stage number，stage number为2的存储着合并前的版本，stage number为3的存储着合并过来的版本。参见<a href="http://book.git-scm.com/7_the_git_index.html">这里</a></p></li>
<li><p>漂亮的git前端工具 &ndash; <a href="http://jonas.nitro.dk/tig/">tig</a></p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/24/notes-on-the-c-programming-language/">C程序设计语言读书笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-24T00:00:00+08:00" pubdate data-updated="true">Mar 24<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/24/notes-on-the-c-programming-language/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/24/notes-on-the-c-programming-language/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>函数与程序结构</h3>

<p>为什么要使用函数?</p>

<ul>
<li>隐藏实现细节</li>
<li>对同一段逻辑，尽可能实现代码复用</li>
</ul>


<p>函数之间的通信可以通过传递参数，函数返回值和外部变量进行。<br/>
关于函数返回值：<br/>
默认函数返回值为int类型
如果返回值为一个表达式，那么表达式的值在返回之前将被转换为函数的类型，这个操作可能会丢失信息，所以某些编译器会给出警告信息。</p>

<p>函数声明<br/>
如果函数声明中不包含参数，如</p>

<pre><code>double atof();
</code></pre>

<p>那么编译器为了兼容老版本的C语言策划你工序，将不会对atof的参数做任何假设，并且会关闭所有的参数检查。所以，如果函数带有参数，则要声明它们；如果没有参数，则使用<strong>void</strong>进行声明。</p>

<p>变量类型</p>

<ul>
<li><p>外部变量</p>

<p>  C语言可以看成是一系列的外部对象构成，这些外部对象包括函数和变量。外部变量可以在全局范围内访问，与内部变量相比，它有更大的作用域和生命周期。任何函数都可以访问一个外部变量，但前提是，<strong>这个变量需要通过某种方式声明</strong>。</p></li>
<li><p>自动变量</p>

<p>  在函数内部声明的变量，包括函数参数称为自动变量，它们在函数每次调用时初始化，函数调用完成后自动销毁。</p></li>
<li><p>静态变量</p>

<p> 用static声明外部变量和函数，可以将其声明的对象的作用域限定为被编译原文件的剩余部分，通过static声明外部对象，可以达到隐藏外部对象的目的。被static声明的函数的函数名除了对该函数声明的所在的文件可见外，其他文件无法访问。</p>

<p> static也可用于声明内部变量，它同自动变量一样是局部变量，与自动变量不同的是，不管其所在的函数是否被调用，它一直存在，一直占据存储空间。</p></li>
<li><p>寄存器变量
  register声明告诉编译器，它所声明的变量在程序中使用的频率较高，暗示将这个变量放在寄存器中，从而执行速度更快，但是，编译器可以选择忽略这个声明。</p>

<p>  register声明只适用于自动变量以及函数的形式参数。</p></li>
</ul>


<p>作用域<br/>
外部变量和函数的作用域从声明它的地方开始，到其所在的文件末尾结束。</p>

<p>变量的声明与定义<br/>
&mdash;> 变量的声明只是说明变量的属性和性质，并不分配存储单元;<br/>
&mdash;> 变量的定义表示要分配存储单元。<br/>
变量的声明有两种：</p>

<ol>
<li><p>定义声明（defining declaration）</p>

<p> 在声明一个变量的时候就为这个变量分配存储空间，这构成了对这个变量的定义。</p></li>
<li><p>引用声明（referencing declaration)</p>

<p> 不会分配存储空间，只是告诉编译器要使用这个变量。<br/>
 变量只能定义一次，但是可以被声明多次。举例如下：</p>

<pre><code> int tern = 1; // 定义声明，声明tern的同时定义tern，导致内存空间的分配
 main() {
  extern int tern; // 引用声明，不会分配内存空间
  int tern = 2; // 错误，重复定义

  extern int var;
 }

 int var = 5;
</code></pre>

<p> 关键字extern表明这是一个引用声明，只做引用，不做定义。extern主要用在：</p>

<ol>
<li>每个需要访问外部变量的函数中，都必须用extern关键字声明相应的外部变量（如上例的tern）;</li>
<li>要在外部变量的定义之前使用该变量(如上例的var变量);</li>
<li>外部变量的定义在一个文件中，而在其他文件中需要通过extern声明来访问它。</li>
</ol>
</li>
</ol>


<p>函数的声明与定义<br/>
函数的声明（函数原型）与定义是分开的。函数在使用前必须要先声明，如果没有函数原型，那么在函数第一次使用的时候会被隐式声明：该函数的返回值被假定为int型，而对函数参数不做任何假设。</p>

<p>初始化<br/>
外部变量和静态变量默认初始化为0，自动变量和寄存器变量的初值没有定义。<br/>
外部变量和静态变量的初始化表达式必须是常量表达式，且只初始化一次。自动变量和寄存器变量的初始化表达式可以不是常量表达式，且在每次进入函数或者程序块时都要被初始化一次。</p>

<p>Reference：</p>

<ul>
<li><a href="http://www.cppblog.com/mymsdn/archive/2008/08/19/59377.aspx">http://www.cppblog.com/mymsdn/archive/2008/08/19/59377.aspx</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/22/rotating-async-tasks/">Rotating Async Tasks</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-22T00:00:00+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/22/rotating-async-tasks/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/22/rotating-async-tasks/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>Originally posted by <a href="http://evancharlton.com/thoughts/rotating-async-tasks">Even Charlton</a>.</strong></p>

<p>A common problem for new Android developers is how to handle screen rotations on the Android platform. Screen rotations cause all sorts of problems if you don&rsquo;t anticipate them because the Activity gets torn down completely and then rebuilt. If you don&rsquo;t handle it properly, AsyncTasks (threads) break completely. I&rsquo;ll show the code first and then talk about why it works. Here&rsquo;s the general pattern.</p>

<h3>The code</h3>

<pre><code>public class MyActivity extends Activity {
    private MyTask mTask;
    @Override
    public void onCreate(Bundle savedInstanceState)
        super.onCreate(savedInstanceState)
        mTask = (MyTask) getLastNonConfigurationInstance();
        if(mTask == null) {
            mTask = new MyTask();
        }
        mTask.activity = this;
        if(mTask.getStatus() == AsyncTask.Status.PENDING) {
            mTask.execute();
        }
    }
    @Override
    public Object onRetainNonConfigurationInstance() {
        return mTask;
    }
    private static class MyTask extends AsyncTask&lt;Params, Progress, Result&gt;() {
        public MyActivity activity;
        @Override
        protected void onPreExecute() {
            // ...
        }
        @Override
        protected Result doInBackground(Params... params) {
            // ...
        }
        @Override
        protected void onProgressUpdate(Progress... updates) {
            // ...
        }
        @Override
        protected void onPostExecute(Result result) {
            // ...
        }
    }
}
</code></pre>

<h3>The explanation</h3>

<p>This works because MyTask is a static class&mdash;it will survive the class being torn down. All you then do is reattach it to the Activity when you recreate the Activity after the rotation. Note that you don&rsquo;t just always call mTask.execute() &mdash; only call it if it hasn&rsquo;t been called before.</p>

<p>Of course this might not be perfect for your situation, but I assume that you can make the necessary modifications for your specific case. Feel free to drop me a line if you have any questions.</p>

<h3>注</h3>

<p>从Api level 11开始引入了<a href="http://developer.android.com/guide/topics/fundamentals/loaders.html">Loader</a>类，该类同AsyncTask一样可以实现异步加载，同时在设计上考虑了configuation改变的场景。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/22/git-change-author-and-email-of-commits/">更改git提交历史信息</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-22T00:00:00+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/22/git-change-author-and-email-of-commits/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/22/git-change-author-and-email-of-commits/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>如果你使用git进行版本控制，不知道你有没有遇到这种情况，提交了几个commit后发现你本地git库的author和email信息配置不是你预想的，这时你想要更新已经提交的commit的author和email信息，怎么办？<br/>
这是stackoverflow上给出的<a href="http://stackoverflow.com/questions/750172/how-do-i-change-the-author-of-a-commit-in-git">做法</a>：</p>

<pre><code>#!/bin/sh

git filter-branch --env-filter '

an="$GIT_AUTHOR_NAME"
am="$GIT_AUTHOR_EMAIL"
cn="$GIT_COMMITTER_NAME"
cm="$GIT_COMMITTER_EMAIL"

if [ "$GIT_COMMITTER_EMAIL" = "your@email.to.match" ]
then
    cn="Your New Committer Name"
    cm="Your New Committer Email"
fi
if [ "$GIT_AUTHOR_EMAIL" = "your@email.to.match" ]
then
    an="Your New Author Name"
    am="Your New Author Email"
fi

export GIT_AUTHOR_NAME="$an"
export GIT_AUTHOR_EMAIL="$am"
export GIT_COMMITTER_NAME="$cn"
export GIT_COMMITTER_EMAIL="$cm"
'
</code></pre>

<p>原文在<a href="http://help.github.com/change-author-info/">这里</a>。</p>

<p>但是问题是，更新本地的提交历史信息后，想要把更新push到远程分支上去，出现non-fast-forward错误，意思是要推送的提交并非继远程版本库最新提交之后的提交，推送会造成覆盖远程仓库的提交。</p>

<pre><code>$ git push origin master
 ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to 'example.git'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. 'git pull') before pushing again.  See the
'Note about fast-forwards' section of 'git push --help' for details.
</code></pre>

<p>使用&mdash;force选项进行强制push即可： <code>git push --force origin master</code>，但是这样会覆盖远程分支上的commit:</p>

<pre><code>-f, --force
    Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the
    check. This can cause the remote repository to lose commits; use it with care.
</code></pre>

<h3>另一种方法</h3>

<p>使用<code>git rebase -i</code> 到你想更改的commit的前一个commit，选择reword选项，然后依次重新提交，这时提交的author和email将会是你本地配置的author和email，rebase完成后commit的author和email信息就更新了。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>Android (12)</a></li>
<li class='category'><a href='/blog/categories/c-/'>C++ (1)</a></li>
<li class='category'><a href='/blog/categories/c语言/'>C语言 (5)</a></li>
<li class='category'><a href='/blog/categories/eclipse/'>Eclipse (2)</a></li>
<li class='category'><a href='/blog/categories/git/'>Git (3)</a></li>
<li class='category'><a href='/blog/categories/http/'>HTTP (1)</a></li>
<li class='category'><a href='/blog/categories/http/'>Http (1)</a></li>
<li class='category'><a href='/blog/categories/java/'>Java (5)</a></li>
<li class='category'><a href='/blog/categories/kindle/'>Kindle (1)</a></li>
<li class='category'><a href='/blog/categories/linux/'>Linux (10)</a></li>
<li class='category'><a href='/blog/categories/shell/'>Shell (1)</a></li>
<li class='category'><a href='/blog/categories/vim/'>Vim (1)</a></li>
<li class='category'><a href='/blog/categories/chromium/'>chromium (1)</a></li>
<li class='category'><a href='/blog/categories/设计模式/'>设计模式 (1)</a></li>
<li class='category'><a href='/blog/categories/读书笔记/'>读书笔记 (3)</a></li>

  </ul>
</section>

<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 90%" href="/tags/c-plus-plus/">C++</a>
<a style="font-size: 156%" href="/tags/cyu-yan/">C语言</a>
<a style="font-size: 210%" href="/tags/android/">android</a>
<a style="font-size: 118%" href="/tags/archlinux/">archlinux</a>
<a style="font-size: 90%" href="/tags/awk/">awk</a>
<a style="font-size: 90%" href="/tags/c/">c</a>
<a style="font-size: 90%" href="/tags/c-plus-plus/">c++</a>
<a style="font-size: 118%" href="/tags/csapp/">csapp</a>
<a style="font-size: 90%" href="/tags/debug/">debug</a>
<a style="font-size: 118%" href="/tags/eclipse/">eclipse</a>
<a style="font-size: 90%" href="/tags/gcc/">gcc</a>
<a style="font-size: 135%" href="/tags/git/">git</a>
<a style="font-size: 90%" href="/tags/github/">github</a>
<a style="font-size: 90%" href="/tags/graphics/">graphics</a>
<a style="font-size: 118%" href="/tags/http/">http</a>
<a style="font-size: 156%" href="/tags/java/">java</a>
<a style="font-size: 90%" href="/tags/kernel/">kernel</a>
<a style="font-size: 90%" href="/tags/kindle/">kindle</a>
<a style="font-size: 175%" href="/tags/linux/">linux</a>
<a style="font-size: 90%" href="/tags/permission/">permission</a>
<a style="font-size: 90%" href="/tags/php/">php</a>
<a style="font-size: 90%" href="/tags/proxy/">proxy</a>
<a style="font-size: 90%" href="/tags/shell/">shell</a>
<a style="font-size: 90%" href="/tags/socket/">socket</a>
<a style="font-size: 163%" href="/tags/todo/">todo</a>
<a style="font-size: 135%" href="/tags/vim/">vim</a>
<a style="font-size: 90%" href="/tags/window/">window</a>
<a style="font-size: 169%" href="/tags/ming-ling/">命令</a>
<a style="font-size: 90%" href="/tags/she-ji-mo-shi/">设计模式</a>
<a style="font-size: 118%" href="/tags/zhuan-zai/">转载</a>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/11/07/awesome-bind-mount/">Bind Mount的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/04/disable-kernel-random-address/">禁用内核进程地址随机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/26/Chrominum-base-code-introduction/">Chromium Base库介绍</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/25/strcpy-memcpy/">Strcpy和memcpy的区别</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/28/eclipse-debug-break-points/">Eclipse 调试中的五种断点</a>
      </li>
    
  </ul>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Calvin Lee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'calvin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
