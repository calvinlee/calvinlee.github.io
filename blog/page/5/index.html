
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>且听风吟</title>
  <meta name="author" content="Calvin Lee">

  
  <meta name="description" content="函数与程序结构 为什么要使用函数? 隐藏实现细节
对同一段逻辑，尽可能实现代码复用 函数之间的通信可以通过传递参数，函数返回值和外部变量进行。
关于函数返回值：
默认函数返回值为int类型
如果返回值为一个表达式，那么表达式的值在返回之前将被转换为函数的类型，这个操作可能会丢失信息， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://calvinlee.github.io/blog/page/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="且听风吟" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">且听风吟</a></h1>
  
    <h2>Don't panic! I'm a programmer.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:calvinlee.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/links.html">Links</a></li>
  <li><a href="/music.html">Music</a></li>
  <li><a href="/about.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/24/notes-on-the-c-programming-language/">C程序设计语言读书笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-24T00:00:00+08:00" pubdate data-updated="true">Mar 24<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/24/notes-on-the-c-programming-language/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/24/notes-on-the-c-programming-language/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>函数与程序结构</h3>

<p>为什么要使用函数?</p>

<ul>
<li>隐藏实现细节</li>
<li>对同一段逻辑，尽可能实现代码复用</li>
</ul>


<p>函数之间的通信可以通过传递参数，函数返回值和外部变量进行。<br/>
关于函数返回值：<br/>
默认函数返回值为int类型
如果返回值为一个表达式，那么表达式的值在返回之前将被转换为函数的类型，这个操作可能会丢失信息，所以某些编译器会给出警告信息。</p>

<p>函数声明<br/>
如果函数声明中不包含参数，如</p>

<pre><code>double atof();
</code></pre>

<p>那么编译器为了兼容老版本的C语言策划你工序，将不会对atof的参数做任何假设，并且会关闭所有的参数检查。所以，如果函数带有参数，则要声明它们；如果没有参数，则使用<strong>void</strong>进行声明。</p>

<p>变量类型</p>

<ul>
<li><p>外部变量</p>

<p>  C语言可以看成是一系列的外部对象构成，这些外部对象包括函数和变量。外部变量可以在全局范围内访问，与内部变量相比，它有更大的作用域和生命周期。任何函数都可以访问一个外部变量，但前提是，<strong>这个变量需要通过某种方式声明</strong>。</p></li>
<li><p>自动变量</p>

<p>  在函数内部声明的变量，包括函数参数称为自动变量，它们在函数每次调用时初始化，函数调用完成后自动销毁。</p></li>
<li><p>静态变量</p>

<p> 用static声明外部变量和函数，可以将其声明的对象的作用域限定为被编译原文件的剩余部分，通过static声明外部对象，可以达到隐藏外部对象的目的。被static声明的函数的函数名除了对该函数声明的所在的文件可见外，其他文件无法访问。</p>

<p> static也可用于声明内部变量，它同自动变量一样是局部变量，与自动变量不同的是，不管其所在的函数是否被调用，它一直存在，一直占据存储空间。</p></li>
<li><p>寄存器变量
  register声明告诉编译器，它所声明的变量在程序中使用的频率较高，暗示将这个变量放在寄存器中，从而执行速度更快，但是，编译器可以选择忽略这个声明。</p>

<p>  register声明只适用于自动变量以及函数的形式参数。</p></li>
</ul>


<p>作用域<br/>
外部变量和函数的作用域从声明它的地方开始，到其所在的文件末尾结束。</p>

<p>变量的声明与定义<br/>
&mdash;> 变量的声明只是说明变量的属性和性质，并不分配存储单元;<br/>
&mdash;> 变量的定义表示要分配存储单元。<br/>
变量的声明有两种：</p>

<ol>
<li><p>定义声明（defining declaration）</p>

<p> 在声明一个变量的时候就为这个变量分配存储空间，这构成了对这个变量的定义。</p></li>
<li><p>引用声明（referencing declaration)</p>

<p> 不会分配存储空间，只是告诉编译器要使用这个变量。<br/>
 变量只能定义一次，但是可以被声明多次。举例如下：</p>

<pre><code> int tern = 1; // 定义声明，声明tern的同时定义tern，导致内存空间的分配
 main() {
  extern int tern; // 引用声明，不会分配内存空间
  int tern = 2; // 错误，重复定义

  extern int var;
 }

 int var = 5;
</code></pre>

<p> 关键字extern表明这是一个引用声明，只做引用，不做定义。extern主要用在：</p>

<ol>
<li>每个需要访问外部变量的函数中，都必须用extern关键字声明相应的外部变量（如上例的tern）;</li>
<li>要在外部变量的定义之前使用该变量(如上例的var变量);</li>
<li>外部变量的定义在一个文件中，而在其他文件中需要通过extern声明来访问它。</li>
</ol>
</li>
</ol>


<p>函数的声明与定义<br/>
函数的声明（函数原型）与定义是分开的。函数在使用前必须要先声明，如果没有函数原型，那么在函数第一次使用的时候会被隐式声明：该函数的返回值被假定为int型，而对函数参数不做任何假设。</p>

<p>初始化<br/>
外部变量和静态变量默认初始化为0，自动变量和寄存器变量的初值没有定义。<br/>
外部变量和静态变量的初始化表达式必须是常量表达式，且只初始化一次。自动变量和寄存器变量的初始化表达式可以不是常量表达式，且在每次进入函数或者程序块时都要被初始化一次。</p>

<p>Reference：</p>

<ul>
<li><a href="http://www.cppblog.com/mymsdn/archive/2008/08/19/59377.aspx">http://www.cppblog.com/mymsdn/archive/2008/08/19/59377.aspx</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/22/rotating-async-tasks/">Rotating Async Tasks</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-22T00:00:00+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/22/rotating-async-tasks/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/22/rotating-async-tasks/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>Originally posted by <a href="http://evancharlton.com/thoughts/rotating-async-tasks">Even Charlton</a>.</strong></p>

<p>A common problem for new Android developers is how to handle screen rotations on the Android platform. Screen rotations cause all sorts of problems if you don&rsquo;t anticipate them because the Activity gets torn down completely and then rebuilt. If you don&rsquo;t handle it properly, AsyncTasks (threads) break completely. I&rsquo;ll show the code first and then talk about why it works. Here&rsquo;s the general pattern.</p>

<h3>The code</h3>

<pre><code>public class MyActivity extends Activity {
    private MyTask mTask;
    @Override
    public void onCreate(Bundle savedInstanceState)
        super.onCreate(savedInstanceState)
        mTask = (MyTask) getLastNonConfigurationInstance();
        if(mTask == null) {
            mTask = new MyTask();
        }
        mTask.activity = this;
        if(mTask.getStatus() == AsyncTask.Status.PENDING) {
            mTask.execute();
        }
    }
    @Override
    public Object onRetainNonConfigurationInstance() {
        return mTask;
    }
    private static class MyTask extends AsyncTask&lt;Params, Progress, Result&gt;() {
        public MyActivity activity;
        @Override
        protected void onPreExecute() {
            // ...
        }
        @Override
        protected Result doInBackground(Params... params) {
            // ...
        }
        @Override
        protected void onProgressUpdate(Progress... updates) {
            // ...
        }
        @Override
        protected void onPostExecute(Result result) {
            // ...
        }
    }
}
</code></pre>

<h3>The explanation</h3>

<p>This works because MyTask is a static class&mdash;it will survive the class being torn down. All you then do is reattach it to the Activity when you recreate the Activity after the rotation. Note that you don&rsquo;t just always call mTask.execute() &mdash; only call it if it hasn&rsquo;t been called before.</p>

<p>Of course this might not be perfect for your situation, but I assume that you can make the necessary modifications for your specific case. Feel free to drop me a line if you have any questions.</p>

<h3>注</h3>

<p>从Api level 11开始引入了<a href="http://developer.android.com/guide/topics/fundamentals/loaders.html">Loader</a>类，该类同AsyncTask一样可以实现异步加载，同时在设计上考虑了configuation改变的场景。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/22/git-change-author-and-email-of-commits/">更改git提交历史信息</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-22T00:00:00+08:00" pubdate data-updated="true">Mar 22<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/22/git-change-author-and-email-of-commits/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/22/git-change-author-and-email-of-commits/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>如果你使用git进行版本控制，不知道你有没有遇到这种情况，提交了几个commit后发现你本地git库的author和email信息配置不是你预想的，这时你想要更新已经提交的commit的author和email信息，怎么办？<br/>
这是stackoverflow上给出的<a href="http://stackoverflow.com/questions/750172/how-do-i-change-the-author-of-a-commit-in-git">做法</a>：</p>

<pre><code>#!/bin/sh

git filter-branch --env-filter '

an="$GIT_AUTHOR_NAME"
am="$GIT_AUTHOR_EMAIL"
cn="$GIT_COMMITTER_NAME"
cm="$GIT_COMMITTER_EMAIL"

if [ "$GIT_COMMITTER_EMAIL" = "your@email.to.match" ]
then
    cn="Your New Committer Name"
    cm="Your New Committer Email"
fi
if [ "$GIT_AUTHOR_EMAIL" = "your@email.to.match" ]
then
    an="Your New Author Name"
    am="Your New Author Email"
fi

export GIT_AUTHOR_NAME="$an"
export GIT_AUTHOR_EMAIL="$am"
export GIT_COMMITTER_NAME="$cn"
export GIT_COMMITTER_EMAIL="$cm"
'
</code></pre>

<p>原文在<a href="http://help.github.com/change-author-info/">这里</a>。</p>

<p>但是问题是，更新本地的提交历史信息后，想要把更新push到远程分支上去，出现non-fast-forward错误，意思是要推送的提交并非继远程版本库最新提交之后的提交，推送会造成覆盖远程仓库的提交。</p>

<pre><code>$ git push origin master
 ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to 'example.git'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. 'git pull') before pushing again.  See the
'Note about fast-forwards' section of 'git push --help' for details.
</code></pre>

<p>使用&mdash;force选项进行强制push即可： <code>git push --force origin master</code>，但是这样会覆盖远程分支上的commit:</p>

<pre><code>-f, --force
    Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the
    check. This can cause the remote repository to lose commits; use it with care.
</code></pre>

<h3>另一种方法</h3>

<p>使用<code>git rebase -i</code> 到你想更改的commit的前一个commit，选择reword选项，然后依次重新提交，这时提交的author和email将会是你本地配置的author和email，rebase完成后commit的author和email信息就更新了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/17/insight-into-android-permission/">Android 权限机制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-17T00:00:00+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/17/insight-into-android-permission/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/17/insight-into-android-permission/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>概要</h3>

<p>Android基于Linux，Android的权限管理基于Linux的权限框架。此外，Android在此基础上为应用程序提供了permission机制，使得应用程序通过“申请-授予”的机制得以访问系统的敏感资源。权限的授予在应用程序安装过程中就已经确定了，在安装过程中，应用程序的gid，uid，pid已经gids都会被分配。Android不支持在运行时动态进行权限授予。<a href="http://developer.android.com/guide/topics/security/security.html#arch">Why?</a></p>

<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Group_identifier#Primary_vs._supplementary">http://en.wikipedia.org/wiki/Group_identifier#Primary_vs._supplementary</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/17/handy-toolbox/">Handy Toolbox</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-17T00:00:00+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/17/handy-toolbox/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/17/handy-toolbox/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这里记录一些我常用的一些方便高效的工具。</p>

<h3>Firefox</h3>

<ul>
<li><a href="http://vimperator.org/vimperator">Vimperator</a></li>
<li><a href="http://sessionmanager.mozdev.org/">Session Manager</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/evernote-web-clipper/">Evernote web clipper</a></li>
<li><a href="http://www.teesoft.info/content/view/118/1/lang,en/">Autopager</a></li>
</ul>


<h3>Thunderbird</h3>

<ul>
<li><a href="https://addons.mozilla.org/en-US/thunderbird/addon/lightning/?src=search">Lightning</a></li>
<li><a href="https://skydrive.live.com/redir.aspx?cid=71573c6596efd6ee&amp;resid=71573C6596EFD6EE!155&amp;parid=71573C6596EFD6EE!154">Firetray</a></li>
</ul>


<h3>画图</h3>

<ul>
<li><a href="https://skydrive.live.com/redir.aspx?cid=71573c6596efd6ee&amp;resid=71573C6596EFD6EE!146&amp;parid=71573C6596EFD6EE!145">JUDE</a> -UML工具</li>
<li><a href="https://skydrive.live.com/redir.aspx?cid=71573c6596efd6ee&amp;resid=71573C6596EFD6EE!196&amp;parid=71573C6596EFD6EE!145">Edraw</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/17/different-reference-types-in-java/">Java的四种引用类型</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-17T00:00:00+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/17/different-reference-types-in-java/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/17/different-reference-types-in-java/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java中有四种引用类型，按其引用强度由强到弱依次为：</p>

<pre><code>Strong reference &gt; Soft reference &gt; Weak reference &gt; Phantom reference
</code></pre>

<h3>Strong reference</h3>

<p>最常用的为strong reference，就是说只要某个对象还被一个强引用引用着，那么GC就不会回收它。使用强引用的一个弊端就是有可能引起内存泄漏。比如有一个hashmap集合，用来存储对象引用，如果你忘了在某个时机把这些元素remove掉，那么这些对象就会在这个hashmap的生命周期内被一直引用而不能被GC回收，更糟糕的是，如果这个对象体积很大，而又如果这个hashmap被声明为static的，那么随着程序的运行，内存总有被撑爆的那一刻。</p>

<h3>Soft reference</h3>

<p>而soft reference 就不同了，在内存资源极度紧张的情况下，GC会将被Soft reference 引用的对象回收以释放内存空间。这个特性非常适合用来做cache：在内存资源充裕的情况下，它和强引用一样，GC不会回收它，而在内存紧张的情况下，GC实在找不到更多可用的空间的情况下，Soft reference的对象会被回收掉。<br/>
以下代码展示了基于Soft reference的缓存类的使用：</p>

<pre><code>/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.providers.contacts;

import com.android.providers.contacts.ContactsDatabaseHelper.NicknameLookupColumns;
import com.android.providers.contacts.ContactsDatabaseHelper.Tables;
import com.google.android.collect.Maps;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import java.lang.ref.SoftReference;
import java.util.BitSet;
import java.util.HashMap;


/**
 * Cache for common nicknames.
 */
public class CommonNicknameCache  {

    // We will use this much memory (in bits) to optimize the nickname cluster lookup
    private static final int NICKNAME_BLOOM_FILTER_SIZE = 0x1FFF;   // =long[128]
    private BitSet mNicknameBloomFilter;

    private HashMap&lt;String, SoftReference&lt;String[]&gt;&gt; mNicknameClusterCache = Maps.newHashMap();

    private final SQLiteDatabase mDb;

    public CommonNicknameCache(SQLiteDatabase db) {
        mDb = db;
    }

    private final static class NicknameLookupPreloadQuery {
        public final static String TABLE = Tables.NICKNAME_LOOKUP;

        public final static String[] COLUMNS = new String[] {
            NicknameLookupColumns.NAME
        };

        public final static int NAME = 0;
    }

    /**
     * Read all known common nicknames from the database and populate a Bloom
     * filter using the corresponding hash codes. The idea is to eliminate most
     * of unnecessary database lookups for nicknames. Given a name, we will take
     * its hash code and see if it is set in the Bloom filter. If not, we will know
     * that the name is not in the database. If it is, we still need to run a
     * query.
     * &lt;p&gt;
     * Given the size of the filter and the expected size of the nickname table,
     * we should expect the combination of the Bloom filter and cache will
     * prevent around 98-99% of unnecessary queries from running.
     */
    private void preloadNicknameBloomFilter() {
        // 这个filter被设计成一个简化的hash表（没有处理hash冲突的情况，实际上也没有必要）
        mNicknameBloomFilter = new BitSet(NICKNAME_BLOOM_FILTER_SIZE + 1);
        Cursor cursor = mDb.query(NicknameLookupPreloadQuery.TABLE,
                NicknameLookupPreloadQuery.COLUMNS,
                null, null, null, null, null);
        try {
            int count = cursor.getCount();
            for (int i = 0; i &lt; count; i++) {
                cursor.moveToNext();
                String normalizedName = cursor.getString(NicknameLookupPreloadQuery.NAME);
                int hashCode = normalizedName.hashCode();
                // 将元素put进hash表（有可能冲突），参见HashMap的put实现
                // 和hashcode做与运算的这个值必须是“hash表长度-1”
                mNicknameBloomFilter.set(hashCode &amp; NICKNAME_BLOOM_FILTER_SIZE);
            }
        } finally {
            cursor.close();
        }
    }

    /**
     * Returns nickname cluster IDs or null. Maintains cache.
     */
    protected String[] getCommonNicknameClusters(String normalizedName) {
        if (mNicknameBloomFilter == null) {
            preloadNicknameBloomFilter();
        }

        int hashCode = normalizedName.hashCode();

        // 如果没有找到，说明cache中**一定**不存在这个key所对应的值;
        // 如果找到了，说明cache中**可能**存在这个key对应的值，需要进一步到cache中查找
        if (!mNicknameBloomFilter.get(hashCode &amp; NICKNAME_BLOOM_FILTER_SIZE)) {
            return null;
        }

        SoftReference&lt;String[]&gt; ref;
        String[] clusters = null;

        // 注意：这里需要同步对cache的访问
        synchronized (mNicknameClusterCache) {
            if (mNicknameClusterCache.containsKey(normalizedName)) {
                ref = mNicknameClusterCache.get(normalizedName);
                if (ref == null) {
                    return null;
                }
                clusters = ref.get();
            }
        }

        // 没有命中，这时才需要到DB中加载，并加入cache
        if (clusters == null) {
            clusters = loadNicknameClusters(normalizedName);
            ref = clusters == null ? null : new SoftReference&lt;String[]&gt;(clusters);
            synchronized (mNicknameClusterCache) {
                mNicknameClusterCache.put(normalizedName, ref);
            }
        }
        return clusters;
    }

    private interface NicknameLookupQuery {
        String TABLE = Tables.NICKNAME_LOOKUP;

        String[] COLUMNS = new String[] {
            NicknameLookupColumns.CLUSTER
        };

        int CLUSTER = 0;
    }

    protected String[] loadNicknameClusters(String normalizedName) {
        String[] clusters = null;
        Cursor cursor = mDb.query(NicknameLookupQuery.TABLE, NicknameLookupQuery.COLUMNS,
                NicknameLookupColumns.NAME + "=?", new String[] { normalizedName },
                null, null, null);
        try {
            int count = cursor.getCount();
            if (count &gt; 0) {
                clusters = new String[count];
                for (int i = 0; i &lt; count; i++) {
                    cursor.moveToNext();
                    clusters[i] = cursor.getString(NicknameLookupQuery.CLUSTER);
                }
            }
        } finally {
            cursor.close();
        }
        return clusters;
    }
}
</code></pre>

<p>这个缓存类实现的实际上是一个二级缓存：</p>

<ol>
<li>第一级是一个BitSet，实现为一个hash表，它充当了一个过滤器的作用。第一次加载时会从db中查找所有的数据，并通过hash算法插入到表中的适当位置，这个过程和HashMap的实现是一样的，只不过没有处理hash冲突的情况，当出现hash冲突时，会覆盖表中原有的值。</li>
<li>第二级是一个HashMap，是真正的cache。其中的元素通过SoftReference引用。</li>
</ol>


<h3>Weak reference</h3>

<p>Weak reference和Soft reference类似，区别在于一旦GC启动，被Weak reference引用的对象就会被回收，而不管当前内存资源是否充裕，因此，被Weak reference引用的对象具有更短的生命周期。但是，由于gc是一个优先级比较低的进程，Weak reference的对象不会像你想象中那么快就被回收了。</p>

<h3>Phantom reference</h3>

<p>Phantom reference 和以上几种引用都不同。它的<code>get()</code>方法永远都会返回null。那么它究竟有什么作用呢？<br/>
TODO&hellip;</p>

<h3>References</h3>

<ul>
<li><a href="http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html">http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html</a></li>
<li><a href="http://improving.iteye.com/blog/436311">http://improving.iteye.com/blog/436311</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/12/differences-bt-noclassdeffounderror-and-classnotfoundexception/">NoClassDefFoundError 和 ClassNotFoundException 的区别</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-12T00:00:00+08:00" pubdate data-updated="true">Mar 12<span>th</span>, 2012</time>
        
           | <a href="/blog/2012/03/12/differences-bt-noclassdeffounderror-and-classnotfoundexception/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/12/differences-bt-noclassdeffounderror-and-classnotfoundexception/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>先看API解释：<br/>
For ClassNotFoundException:</p>

<pre><code>Thrown when an application tries to load in a class through its string name using:

    * The forName method in class Class.
    * The findSystemClass method in class ClassLoader.
    * The loadClass method in class ClassLoader.

but no definition for the class with the specified name could be found.
</code></pre>

<p>For NoClassDefFoundError:</p>

<pre><code>Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.

The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.
</code></pre>

<p>简单的说，就是如果使用new SomeClass()的方式创建对象的，而这时ClassLoader装载SomeClass失败（可能因为权限不够，JNI错误,etc），就会抛出NoClassDefFoundError。<br/>
而如果使用反射来装载一个对象，但是SomeClass不在CLASSPATH中，这时就会抛出ClassNotFoundException。</p>

<p>Reference:<br/>
<a href="http://stackoverflow.com/questions/1457863/what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception">http://stackoverflow.com/questions/1457863/what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/02/my-first-post-on-git-pages/">使用Github Pages创建个人博客</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-02T00:00:00+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/02/my-first-post-on-git-pages/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/02/my-first-post-on-git-pages/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Github pages 是什么？</h2>

<p>Github pages借助 git 工具和Jekyll（一个静态网站生成器），使得你可以将内容push到github，然后通过Jekyll发布成个人blog站点。通过github pages创建个人博客，至少有几个好处：</p>

<ul>
<li>文章内容使用markdown标记语言书写，你可以使用任何你喜欢的文本编辑器编辑文章。</li>
<li>由于git的存在，你可以轻松的对你的文章进行版本控制。</li>
<li>尤其重要的一点，在天朝，你无需担心哪天你的站点被无端屏蔽，还得爬墙过去抢救数据&mdash;因为你本地就有一套完整的站点，而且都是文本格式，非常易于备份。</li>
</ul>


<h2>搭建步骤</h2>

<h3>创建github帐号</h3>

<p>首先，你需要一个github帐号。
登录github后，创建一个USERNAME.github.com的repository，根据向导生成pages。</p>

<h3>安装本地环境</h3>

<p>你需要在本地搭建运行环境，这样在编写文章的时候你可以在本地进行充分的调整，满意后再push到github。
以下基于Ubuntu 10.04LTS系统安装，需要安装的包包括Ruby，RubyGems，jekyll和rake。</p>

<pre><code>$ sudo apt-get install ruby1.9.1-full rubygems1.9.1
</code></pre>

<p>然后通过gem命令安装jekyll</p>

<pre><code>$ sudo gem install jekyll
WARNING:  You don't have /home/calvin/.gem/ruby/1.9.1/bin in your PATH,
      gem executables will not run.
ERROR:  Error installing jekyll:
    liquid requires RubyGems version &gt;= 1.3.7
</code></pre>

<p>安装会出错，提示RubyGems版本过低。这时候需要到<a href="http://packages.ubuntu.com/maverick/all/rubygems1.8/download">http://packages.ubuntu.com/maverick/all/rubygems1.8/download</a> 下载离线安装包安装：</p>

<pre><code>$ sudo dpkg -i Downloads/rubygems1.8_1.3.7-2_all.deb
</code></pre>

<p>安装完成后查看gem版本：</p>

<pre><code>$ which gem
/usr/bin/gem
$ gem -v
1.3.7
</code></pre>

<p>这时候可以继续安装jekyll了：</p>

<pre><code>$ sudo gem install jekyll
</code></pre>

<p>安装jekyll后还需要安装rake工具，通过rake工具可以用来创建新的文章和页面，安装主题等等，十分方便。</p>

<pre><code>$ sudo apt-get install rake
</code></pre>

<p>通过rake -T命令可以查看所有可用命令：</p>

<pre><code>$ rake -T
(in /home/calvin/development/github/calvinlee.github.com)
rake page           # Create a new page.
rake post           # Begin a new post in ./_posts
rake preview        # Launch preview environment
rake theme:install  # Install theme
rake theme:package  # Package theme
rake theme:switch   # Switch between Jekyll-bootstrap themes.
</code></pre>

<h3>安装Jekyll Bootstrap</h3>

<p>由于jekyll仅仅是一个静态html的生成器，它不包含任何页面的templates，所以如果从头开始构建你的博客站点的话，还将要有很多工作要做。幸好，<a href="http://jekyllbootstrap.com/">Jekyll Bootstrap</a>已经提供了一套基本的构架，我们只需要在它的基础上定制，使之符合你口味即可。</p>

<pre><code>$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com
$ cd USERNAME.github.com
$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git
$ git push origin master
</code></pre>

<h3>开始个性博客之旅</h3>

<p>首先在本地启动jekyll：</p>

<pre><code>$ /var/lib/gems/1.8/gems/jekyll-0.11.2/bin/jekyll --server
</code></pre>

<p>然后你可以访问<a href="http://localhost:4000%E6%9F%A5%E7%9C%8BJekyll">http://localhost:4000%E6%9F%A5%E7%9C%8BJekyll</a> Bootstrap给你提供了什么，之后你就可以开始写你的文章了。</p>

<pre><code>$ rake post title="my-first-post-on-git-pages" date="2012-03-02"
</code></pre>

<p>rake工具会为你生成posts/2012-03-02-my-first-post-on-git-pages.md
你可以开始使用markdown标记语言编辑文章了！</p>

<h3>发布</h3>

<p>发布很简单，直接将文章内容推送到github即可，如果你修改了页面主题或者布局，也一并推送：</p>

<pre><code>$ git add .
$ git commit -m "Add new post"
$ git push origin master
</code></pre>

<p>现在你就可以通过<a href="http://USERNAME.github.com%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82">http://USERNAME.github.com%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82</a></p>

<h3>Reference</h3>

<ul>
<li><a href="http://daringfireball.net/projects/markdown/syntax">详尽的Markdown语法</a></li>
<li><a href="http://www.pushiming.com/blog/2010/11/tips-on-markdown/">另外一篇Markdown简介</a></li>
<li><a href="https://github.com/mojombo/jekyll/wiki/">Jekyll wiki</a></li>
<li><a href="https://github.com/mojombo/jekyll/wiki/Sites">这里</a>是一些站点，有些是开放源代码的，你可以参照学习</li>
<li><a href="https://github.com/mojombo/jekyll/wiki/Pagination">怎样对文章进行分页？</a></li>
<li><a href="http://www.pizn.net/24-09-2011/use-github-pages-to-build-a-blog/">http://www.pizn.net/24-09-2011/use-github-pages-to-build-a-blog/</a></li>
<li><a href="http://www.yangzhiping.com/tech/writing-space.html">http://www.yangzhiping.com/tech/writing-space.html</a></li>
<li><a href="http://fastr.github.com/articles/Documenting-with-Jekyll.html">http://fastr.github.com/articles/Documenting-with-Jekyll.html</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/02/android-vold/">Android Vold 分析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-02T00:00:00+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2012</time>
        
           | <a href="/blog/2012/03/02/android-vold/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2012/03/02/android-vold/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Vold(Volume Daemon) 主要负责管理和控制外部存储设备，这些控制包括SD卡设备插拔，挂载，格式化等等.
Vold在Android 平台上的作用相当于udev在Linux平台上的功能。</p>

<h3>Vold的架构</h3>

<p>Vold的架构大致如图：</p>

<p><a href="/images/vold-architecture.png"><img src="/images/vold-architecture.png" alt="/images/vold-architecture.png" /></a></p>

<ul>
<li>Kernel：detect device hot-plug, load drivers</li>
<li>Sysfs: generate events and send it to user space</li>
<li>NetlinkManager: establish connection to sysfs, listen to uevents and process it</li>
<li>VolumeManager: disk volume operation</li>
<li>CommandListener:  wait for commands from MountService</li>
<li>NativeDaemonConnector:establish connection between MountService and vold daemon</li>
</ul>


<p>其中，一张SD卡对应一个DirectVolume对象。</p>

<p>Vold模块的类图如下：</p>

<p><a href="/images/vold-class-diagram.png"><img src="/images/vold-class-diagram.png" alt="/images/vold-class-diagram.png" /></a></p>

<h3>Vold startup</h3>

<p>vold的启动分为两个过程，一是vold daemon的启动，二是Java层MountService的启动。</p>

<h4>启动Vold daemon</h4>

<p>Vold daemon由init进程启动，参见init.rc片段：</p>

<p><a href="/images/vold-initrc.png"><img src="/images/vold-initrc.png" alt="/images/vold-initrc.png" /></a></p>

<p>vold入口函数位于/system/vold/mail.cpp，启动后处理流程如下：</p>

<p><a href="/images/vold-startup-sequence.png"><img src="/images/vold-startup-sequence.png" alt="/images/vold-startup-sequence.png" /></a></p>

<p>1.Create directory /dev/block/vold
1.Create singleton instance of VolumeManager , NetlinkManager  andCommandListener
1.Process configuration file /system/etc/vold.fstab
1.NetlinkManager creates connection between kernel and vold
1.Manually trigger uevents by writing “add\n” to file in /sys/block
1.CommandListener  starts listening commands from framework</p>

<h4>启动MountService</h4>

<p>1.MountService initialized by SystemServer on device starts up
1.Create connection to vold</p>

<p>After MountService is up, the vold system is ready.</p>

<h3>Send commands from framework</h3>

<p>以App层通过MountService 挂载一个volume为例，说明从上层向下层的调用流程。</p>

<p><a href="/images/vold-send-commands-from-framework.png"><img src="/images/vold-send-commands-from-framework.png" alt="/images/vold-send-commands-from-framework.png" /></a></p>

<ol>
<li>NativeDaemonConnector::sendCommand()</li>
<li>SocketListener::runListener() <code>&lt;</code>&mdash;vold accepting connections here</li>
<li>FrameworkListener::onDataAvailable()</li>
<li>FrameworkListener::dispatchCommand()</li>
<li>FrameworkCommand::runCommand()&mdash;-CommandListener::VolumeCmd::runCommand()</li>
<li>VolumeManager::mountVolume()</li>
<li>Volume::mountVol()</li>
</ol>


<h3>Process events from kernel</h3>

<p>处理kernel发出的挂载事件：</p>

<p><a href="/images/vold-process-events-from-kernel.png"><img src="/images/vold-process-events-from-kernel.png" alt="/images/vold-process-events-from-kernel.png" /></a></p>

<ol>
<li>SocketListener::runListener <code>&lt;</code>&mdash;listening events from kernel</li>
<li>NetlinkListener::onDataAvailable()</li>
<li>NetlinkHandler::onEvent()</li>
<li>VolumeManager::handleBlockEvent , VolumeManager::handleSwitchEvent , VolumeManager::handleUsbCompositeEvent</li>
<li>DirectVolume::handleBlockEvent()</li>
<li>DirectVolume::handleDiskAdded, DirectVolume::handlePartitionAdded, DirectVolume::handleDiskRemoved, DirectVolume::handlePartitionRemoved,DirectVolume::handleDiskChanged, DirectVolume::handlePartitionChanged,or ignore non add/remove/change event</li>
</ol>


<h3>Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/qianjin0703/article/details/6362389">http://blog.csdn.net/qianjin0703/article/details/6362389</a></li>
<li><a href="http://www.cnblogs.com/iceocean/articles/1594195.html">http://www.cnblogs.com/iceocean/articles/1594195.html</a></li>
<li><a href="http://www.chinaunix.net/jh/4/822500.html">http://www.chinaunix.net/jh/4/822500.html</a></li>
<li><a href="http://blog.csdn.net/fudan_abc/article/details/1768277">http://blog.csdn.net/fudan_abc/article/details/1768277</a></li>
<li><a href="http://dongyulong.blog.51cto.com/1451604/389159">http://dongyulong.blog.51cto.com/1451604/389159</a></li>
<li><a href="http://blog.csdn.net/datangsoc/article/details/5928132">http://blog.csdn.net/datangsoc/article/details/5928132</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/18/install-wireless-driver-on-ubuntu-1004/">Ubuntu10.04安装无线网卡ath9k_htc驱动</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-18T00:00:00+08:00" pubdate data-updated="true">Oct 18<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/10/18/install-wireless-driver-on-ubuntu-1004/#disqus_thread"
             data-disqus-identifier="http://calvinlee.github.io/blog/2011/10/18/install-wireless-driver-on-ubuntu-1004/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我的USB无线网卡型号为TL_WN721N，插在Ubuntu10.04上没有反应。据说10.10以后插上就可以用了，没有测试。</p>

<p>第一步 确定ath9k_htc驱动支持你的网卡型号<br/>
<a href="http://linuxwireless.org/en/users/Drivers/ath9k_htc/devices">这里</a> 列出了支持的型号列表，你可以通过lsusb查看自己的网卡型号是否在列表当中。</p>

<p>第二步 安装firmwire<br/>
从<a href="http://wireless.kernel.org/download/htc_fw/">这里</a>下载htc_9271.fw，拷贝到/lib/firmwire下</p>

<p>第三步 安装compact wireless<br/>
安装compact wireless有打包好的deb包，从这里下载GUI Program to install ath9k_htc，安装完后直接运行，等待安装完成重启机器就可以了。
爱折腾的也可以到<a href="http://wireless.kernel.org/download/">这里</a>下载
最新的compact wireless驱动，然后编译安装：</p>

<pre><code>sudo make
sudo make install
sudo make unload
sudo make load ath9k_htc
</code></pre>

<p>重启机器即可。</p>

<p>Reference
* <a href="http://forum.ubuntu.com.cn/viewtopic.php?f=116&amp;t=326568&amp;p=2388841">http://forum.ubuntu.com.cn/viewtopic.php?f=116&amp;t=326568&amp;p=2388841</a>
* <a href="http://blog.chinaunix.net/space.php?uid=20620288&amp;do=blog&amp;id=2691282">http://blog.chinaunix.net/space.php?uid=20620288&amp;do=blog&amp;id=2691282</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/11/11/introducing-pmap/">Pmap介绍</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/07/awesome-bind-mount/">Bind Mount的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/04/disable-kernel-random-address/">禁用内核进程地址随机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/26/Chrominum-base-code-introduction/">Chromium Base库介绍</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/25/strcpy-memcpy/">Strcpy和memcpy的区别</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>Android (10)</a></li>
<li class='category'><a href='/blog/categories/c语言/'>C语言 (4)</a></li>
<li class='category'><a href='/blog/categories/eclipse/'>Eclipse (2)</a></li>
<li class='category'><a href='/blog/categories/git/'>Git (3)</a></li>
<li class='category'><a href='/blog/categories/http/'>HTTP (1)</a></li>
<li class='category'><a href='/blog/categories/http/'>Http (1)</a></li>
<li class='category'><a href='/blog/categories/java/'>Java (5)</a></li>
<li class='category'><a href='/blog/categories/kindle/'>Kindle (1)</a></li>
<li class='category'><a href='/blog/categories/linux/'>Linux (11)</a></li>
<li class='category'><a href='/blog/categories/shell/'>Shell (1)</a></li>
<li class='category'><a href='/blog/categories/vim/'>Vim (1)</a></li>
<li class='category'><a href='/blog/categories/chromium/'>chromium (1)</a></li>
<li class='category'><a href='/blog/categories/设计模式/'>设计模式 (1)</a></li>
<li class='category'><a href='/blog/categories/读书笔记/'>读书笔记 (2)</a></li>

  </ul>
</section>

<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 158%" href="/tags/cyu-yan/">C语言</a>
<a style="font-size: 210%" href="/tags/android/">android</a>
<a style="font-size: 119%" href="/tags/archlinux/">archlinux</a>
<a style="font-size: 90%" href="/tags/awk/">awk</a>
<a style="font-size: 90%" href="/tags/c-plus-plus/">c++</a>
<a style="font-size: 90%" href="/tags/csapp/">csapp</a>
<a style="font-size: 90%" href="/tags/debug/">debug</a>
<a style="font-size: 119%" href="/tags/eclipse/">eclipse</a>
<a style="font-size: 90%" href="/tags/gcc/">gcc</a>
<a style="font-size: 137%" href="/tags/git/">git</a>
<a style="font-size: 90%" href="/tags/github/">github</a>
<a style="font-size: 119%" href="/tags/http/">http</a>
<a style="font-size: 158%" href="/tags/java/">java</a>
<a style="font-size: 90%" href="/tags/kernel/">kernel</a>
<a style="font-size: 90%" href="/tags/kindle/">kindle</a>
<a style="font-size: 178%" href="/tags/linux/">linux</a>
<a style="font-size: 90%" href="/tags/permission/">permission</a>
<a style="font-size: 90%" href="/tags/php/">php</a>
<a style="font-size: 90%" href="/tags/proxy/">proxy</a>
<a style="font-size: 90%" href="/tags/shell/">shell</a>
<a style="font-size: 90%" href="/tags/socket/">socket</a>
<a style="font-size: 149%" href="/tags/todo/">todo</a>
<a style="font-size: 137%" href="/tags/vim/">vim</a>
<a style="font-size: 90%" href="/tags/window/">window</a>
<a style="font-size: 178%" href="/tags/ming-ling/">命令</a>
<a style="font-size: 90%" href="/tags/she-ji-mo-shi/">设计模式</a>
<a style="font-size: 119%" href="/tags/zhuan-zai/">转载</a>

  </ul>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Calvin Lee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'calvin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
