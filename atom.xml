<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[且听风吟]]></title>
  <link href="http://calvinlee.github.io/atom.xml" rel="self"/>
  <link href="http://calvinlee.github.io/"/>
  <updated>2013-11-12T11:27:03+08:00</updated>
  <id>http://calvinlee.github.io/</id>
  <author>
    <name><![CDATA[Calvin Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[pmap介绍]]></title>
    <link href="http://calvinlee.github.io/blog/2013/11/11/introducing-pmap/"/>
    <updated>2013-11-11T18:36:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/11/11/introducing-pmap</id>
    <content type="html"><![CDATA[<p>pmap用来打印进程地址空间占用。通常也可以通过如下命令来查看：</p>

<pre><code>cat /proc/self/maps 
</code></pre>

<p>但用pmap包含更多的信息，显示结果也更直观:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pmap -d 4827
</span><span class='line'>    4827:   bash
</span><span class='line'>    Address           Kbytes Mode  Offset           Device    Mapping
</span><span class='line'>    0000000000400000     896 r-x-- 0000000000000000 008:00005 bash
</span><span class='line'>    00000000006e0000       4 r---- 00000000000e0000 008:00005 bash
</span><span class='line'>    00000000006e1000      36 rw--- 00000000000e1000 008:00005 bash
</span><span class='line'>    00000000006ea000      24 rw--- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    0000000001a8d000    5388 rw--- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    00007f1c6c5cd000      48 r-x-- 0000000000000000 008:00005 libnss_files-2.15.so
</span><span class='line'>    00007f1c6c5d9000    2044 ----- 000000000000c000 008:00005 libnss_files-2.15.so
</span><span class='line'>    00007f1c6c7d8000       4 r---- 000000000000b000 008:00005 libnss_files-2.15.so
</span><span class='line'>    00007f1c6c7d9000       4 rw--- 000000000000c000 008:00005 libnss_files-2.15.so
</span><span class='line'>    00007f1c6c7da000      40 r-x-- 0000000000000000 008:00005 libnss_nis-2.15.so
</span><span class='line'>    00007f1c6c7e4000    2048 ----- 000000000000a000 008:00005 libnss_nis-2.15.so
</span><span class='line'>    00007f1c6c9e4000       4 r---- 000000000000a000 008:00005 libnss_nis-2.15.so
</span><span class='line'>    00007f1c6c9e5000       4 rw--- 000000000000b000 008:00005 libnss_nis-2.15.so
</span><span class='line'>    00007f1c6c9e6000      92 r-x-- 0000000000000000 008:00005 libnsl-2.15.so
</span><span class='line'>    00007f1c6c9fd000    2044 ----- 0000000000017000 008:00005 libnsl-2.15.so
</span><span class='line'>    00007f1c6cbfc000       4 r---- 0000000000016000 008:00005 libnsl-2.15.so
</span><span class='line'>    00007f1c6cbfd000       4 rw--- 0000000000017000 008:00005 libnsl-2.15.so
</span><span class='line'>    00007f1c6cbfe000       8 rw--- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    00007f1c6cc00000      32 r-x-- 0000000000000000 008:00005 libnss_compat-2.15.so
</span><span class='line'>    00007f1c6cc08000    2044 ----- 0000000000008000 008:00005 libnss_compat-2.15.so
</span><span class='line'>    00007f1c6ce07000       4 r---- 0000000000007000 008:00005 libnss_compat-2.15.so
</span><span class='line'>    00007f1c6ce08000       4 rw--- 0000000000008000 008:00005 libnss_compat-2.15.so
</span><span class='line'>    00007f1c6ce09000    7052 r---- 0000000000000000 008:00005 locale-archive
</span><span class='line'>    00007f1c6d4ec000    1748 r-x-- 0000000000000000 008:00005 libc-2.15.so
</span><span class='line'>    00007f1c6d6a1000    2048 ----- 00000000001b5000 008:00005 libc-2.15.so
</span><span class='line'>    00007f1c6d8a1000      16 r---- 00000000001b5000 008:00005 libc-2.15.so
</span><span class='line'>    00007f1c6d8a5000       8 rw--- 00000000001b9000 008:00005 libc-2.15.so
</span><span class='line'>    00007f1c6d8a7000      20 rw--- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    00007f1c6d8ac000       8 r-x-- 0000000000000000 008:00005 libdl-2.15.so
</span><span class='line'>    00007f1c6d8ae000    2048 ----- 0000000000002000 008:00005 libdl-2.15.so
</span><span class='line'>    00007f1c6daae000       4 r---- 0000000000002000 008:00005 libdl-2.15.so
</span><span class='line'>    00007f1c6daaf000       4 rw--- 0000000000003000 008:00005 libdl-2.15.so
</span><span class='line'>    00007f1c6dab0000     136 r-x-- 0000000000000000 008:00005 libtinfo.so.5.9
</span><span class='line'>    00007f1c6dad2000    2048 ----- 0000000000022000 008:00005 libtinfo.so.5.9
</span><span class='line'>    00007f1c6dcd2000      16 r---- 0000000000022000 008:00005 libtinfo.so.5.9
</span><span class='line'>    00007f1c6dcd6000       4 rw--- 0000000000026000 008:00005 libtinfo.so.5.9
</span><span class='line'>    00007f1c6dcd7000     136 r-x-- 0000000000000000 008:00005 ld-2.15.so
</span><span class='line'>    00007f1c6ded7000      12 rw--- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    00007f1c6def0000      28 r--s- 0000000000000000 008:00005 gconv-modules.cache
</span><span class='line'>    00007f1c6def7000       8 rw--- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    00007f1c6def9000       4 r---- 0000000000022000 008:00005 ld-2.15.so
</span><span class='line'>    00007f1c6defa000       8 rw--- 0000000000023000 008:00005 ld-2.15.so
</span><span class='line'>    00007fffe147d000     132 rw--- 0000000000000000 000:00000   [ stack ]
</span><span class='line'>    00007fffe15ff000       4 r-x-- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    ffffffffff600000       4 r-x-- 0000000000000000 000:00000   [ anon ]
</span><span class='line'>    mapped: 30276K    writeable/private: 5668K    shared: 28K</span></code></pre></td></tr></table></div></figure>


<p>可以看出，这个进程的虚拟地址空间大小微30276k，实际占用的物理内存微5668k。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bind mount的使用]]></title>
    <link href="http://calvinlee.github.io/blog/2013/11/07/awesome-bind-mount/"/>
    <updated>2013-11-07T18:10:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/11/07/awesome-bind-mount</id>
    <content type="html"><![CDATA[<p>如果你需要暂时修改一个配置文件用来测试，但是这个配置文件是read only的，你不想大费周折，怎么办？这时bind mount就可以派上用场。</p>

<p>mount命令的常规用法是将一个<em>块设备</em>上的文件系统挂载一个指定的路径。而bind选项可以将一个目录挂载到一个指定的路径。</p>

<p>假设我们需要临时修改一下config文件，但是当前用户没有权限修改这个文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls /tmp/etc/
</span><span class='line'>total 0
</span><span class='line'>-rw-r----- 1 root root 0 Nov 12 10:38 config
</span><span class='line'>$ sudo cat /tmp/etc/config 
</span><span class='line'>sky=0</span></code></pre></td></tr></table></div></figure>


<p>现在我们将/tmp/bind_dir挂载到/tmp/etc：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo mount --bind /tmp/bind_dir /tmp/etc
</span><span class='line'>    $ ls /tmp/bind_dir/
</span><span class='line'>    total 0
</span><span class='line'>    $ ls /tmp/etc/
</span><span class='line'>    total 0</span></code></pre></td></tr></table></div></figure>


<p>现在/tmp/bind_dir被挂载到了/tmp/etc，也就是说访问/tmp/etc实际上是访问的是/etc/bind_dir目录。现在我们可以往/tmp/etc目录写入我们想要的修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch /tmp/etc/config
</span><span class='line'>    $ echo "tmp=1" >> /tmp/etc/config
</span><span class='line'>    $ cat /tmp/etc/config
</span><span class='line'>    tmp=1</span></code></pre></td></tr></table></div></figure>


<p>现在就达到了修改/tmp/etc/config的目的，可以执行测试。测试完毕后，执行umount：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo umount /tmp/etc/</span></code></pre></td></tr></table></div></figure>


<p>/tmp/etc目录下的内容没有变化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo umount /tmp/etc/
</span><span class='line'>$ ls /tmp/etc/
</span><span class='line'>total 4.0K
</span><span class='line'>-rw-r----- 1 root root 6 Nov 12 10:41 config
</span><span class='line'>$ sudo cat /tmp/etc/config
</span><span class='line'>sky=0</span></code></pre></td></tr></table></div></figure>


<p>mount的过程实际上是inode被替换的过程，这里我们将/tmp/bind_dir挂载到/tmp/etc上，实际上的实现过程是将/tmp/etc的dentry目录项所指向的inode重定向到/tmp/bind_dir的inode索引节点，也就是说让/tmp/bind_dir和/tmp/etc指向同一个inode节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -lid /tmp/bind\_dir/ /tmp/etc/
</span><span class='line'>1094756 drwxrwxr-x 2 calvin calvin 4.0K Nov 12 10:47 /tmp/bind\_dir/
</span><span class='line'>1094756 drwxrwxr-x 2 calvin calvin 4.0K Nov 12 10:47 /tmp/etc/</span></code></pre></td></tr></table></div></figure>


<p>可见两个路径都指向了1094756的inode索引节点。</p>

<p>另外几个应用bind mount的例子：<br/>
* <a href="http://docs.1h.com/Bind_mounts">http://docs.1h.com/Bind_mounts</a><br/>
* <a href="http://backdrift.org/how-to-use-bind-mounts-in-linux">http://backdrift.org/how-to-use-bind-mounts-in-linux</a></p>

<h1>Reference</h1>

<p><a href="http://alanwu.blog.51cto.com/3652632/1105681">ext3 mount过程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[禁用内核进程地址随机]]></title>
    <link href="http://calvinlee.github.io/blog/2013/11/04/disable-kernel-random-address/"/>
    <updated>2013-11-04T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/11/04/disable-kernel-random-address</id>
    <content type="html"><![CDATA[<p>今天接触了Linux下的VDSO（Virtual Dynamically-linked Shared Object)，用来使系统调用更加快速和高效，但在查看进程vdso.so在进程地址空间的分布时，发现每次打印出来的进程地址都不一样：</p>

<pre><code>$ ldd /bin/ls
    linux-vdso.so.1 =&gt;  (0x00007ffff7ffe000)
    libselinux.so.1 =&gt; /lib/x86\_64-linux-gnu/libselinux.so.1 (0x00007ffff7dc0000)
    librt.so.1 =&gt; /lib/x86\_64-linux-gnu/librt.so.1 (0x00007ffff7bb8000)
    libacl.so.1 =&gt; /lib/x86\_64-linux-gnu/libacl.so.1 (0x00007ffff79af000)
    libc.so.6 =&gt; /lib/x86\_64-linux-gnu/libc.so.6 (0x00007ffff75ef000)
    libdl.so.2 =&gt; /lib/x86\_64-linux-gnu/libdl.so.2 (0x00007ffff73eb000)
    /lib64/ld-linux-x86-64.so.2 (0x0000555555554000)
    libpthread.so.0 =&gt; /lib/x86\_64-linux-gnu/libpthread.so.0 (0x00007ffff71cd000)
    libattr.so.1 =&gt; /lib/x86\_64-linux-gnu/libattr.so.1 (0x00007ffff6fc8000)
$ cat /proc/self/maps 
00400000-0040b000 r-xp 00000000 08:05 1438995                            /bin/cat
0060a000-0060b000 r--p 0000a000 08:05 1438995                            /bin/cat
0060b000-0060c000 rw-p 0000b000 08:05 1438995                            /bin/cat
0060c000-0062d000 rw-p 00000000 00:00 0                                  [heap]
7ffff7337000-7ffff7a1a000 r--p 00000000 08:05 137790                     /usr/lib/locale/locale-archive
7ffff7a1a000-7ffff7bcf000 r-xp 00000000 08:05 407680                     /lib/x86\_64-linux-gnu/libc-2.15.so
7ffff7bcf000-7ffff7dcf000 ---p 001b5000 08:05 407680                     /lib/x86\_64-linux-gnu/libc-2.15.so
7ffff7dcf000-7ffff7dd3000 r--p 001b5000 08:05 407680                     /lib/x86\_64-linux-gnu/libc-2.15.so
7ffff7dd3000-7ffff7dd5000 rw-p 001b9000 08:05 407680                     /lib/x86\_64-linux-gnu/libc-2.15.so
7ffff7dd5000-7ffff7dda000 rw-p 00000000 00:00 0 
7ffff7dda000-7ffff7dfc000 r-xp 00000000 08:05 407692                     /lib/x86\_64-linux-gnu/ld-2.15.so
7ffff7fd9000-7ffff7fdc000 rw-p 00000000 00:00 0 
7ffff7ff9000-7ffff7ffb000 rw-p 00000000 00:00 0 
7ffff7ffb000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]
7ffff7ffc000-7ffff7ffd000 r--p 00022000 08:05 407692                     /lib/x86\_64-linux-gnu/ld-2.15.so
7ffff7ffd000-7ffff7fff000 rw-p 00023000 08:05 407692                     /lib/x86\_64-linux-gnu/ld-2.15.so
7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</code></pre>

<p>原来在现代Linux内核中，为了安全起见，会对每个进程的进程地址进行随机化。用以下命令即可禁用这个功能：</p>

<pre><code>echo "0" &gt; /proc/sys/kernel/randomize_va_space
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium base库介绍]]></title>
    <link href="http://calvinlee.github.io/blog/2013/09/26/Chrominum-base-code-introduction/"/>
    <updated>2013-09-26T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/09/26/Chrominum-base-code-introduction</id>
    <content type="html"><![CDATA[<p>Chromium的base库包含了一些常用的基础代码，包括:</p>

<pre><code>* 文件操作
* json读写
* 字符串操作
* 时间操作
* 智能指针
</code></pre>

<p>在线代码浏览：
<a href="https://code.google.com/p/chromium/codesearch#chromium/src/base/">https://code.google.com/p/chromium/codesearch#chromium/src/base/</a></p>

<h3>常用宏</h3>

<ol>
<li>DISALLOW_COPY/DISALLOW_ASSIGN/DISALLOW_COPY_AND_ASSIGN
位于base/basictyps.h，它通过将拷贝构造函数和=运算符重载设置为private来禁用类对象的拷贝和赋值操作。
示例用法：sql/transaction.h</li>
</ol>


<h3>智能指针</h3>

<p>scoped_ptr: base/memory/scoped_ptr.h
经过scoped_ptr封装的指针在出作用域后自动被释放, 该指针的ownership只能传递，不能拷贝。使用方法见头文件的注释。</p>

<h3>文件操作</h3>

<p>base/platform_file.h
base/file_util.h
base/files/file_path.h
base/path_service.h</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[strcpy和memcpy的区别]]></title>
    <link href="http://calvinlee.github.io/blog/2013/02/25/strcpy-memcpy/"/>
    <updated>2013-02-25T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/02/25/strcpy-memcpy</id>
    <content type="html"><![CDATA[<p>今天被问到strcpy和memcpy的区别，一时语塞，于是研究一下记录下来。</p>

<h3>strcpy</h3>

<pre><code>   #include &lt;string.h&gt;
   char *strcpy(char *dest, const char *src);
</code></pre>

<p>它的作用是将src指向的字符串，包括最后的&#8217;\0&#8217;，拷贝到dest指向的字符串。它的一个简单实现如下：</p>

<pre><code>       char*
       strncpy(char *dest, const char *src, size_t n){
           size_t i;

           for (i = 0 ; i &lt; n &amp;&amp; src[i] != '\0' ; i++)
               dest[i] = src[i];
           for ( ; i &lt; n ; i++)
               dest[i] = '\0';

           return dest;
       }
</code></pre>

<p>也就是说，strcpy会从头开始依次拷贝每个字符，但是一旦遇到了空字符NULL（&#8217;\0&#8217;），strcpy就会停止拷贝。</p>

<h3>memcpy</h3>

<pre><code>   #include &lt;string.h&gt;
   void *memcpy(void *dest, const void *src, size_t n);
</code></pre>

<p>memcpy用来进行内存拷贝，它将src指向的地址后的n个字节拷贝到dest开始的内存里，可以用它拷贝任何内型的数据对象。</p>

<hr />

<p>以下是stackoverflow上的一个demo，它清楚的显示了这两个函数的区别：</p>

<pre><code>void dump5(char *str);

int main()
{
    char s[5]={'s','a','\0','c','h'};

    char membuff[5]; 
    char strbuff[5];
    memset(membuff, 0, 5); // init both buffers to nulls
    memset(strbuff, 0, 5);

    strcpy(strbuff,s);
    memcpy(membuff,s,5);

    dump5(membuff); // show what happened
    dump5(strbuff);

    return 0;
}

void dump5(char *str)
{
    char *p = str;
    for (int n = 0; n &lt; 5; ++n)
    {
        printf("%2.2x ", *p);
        ++p;
    }

    printf("\t");

    p = str;
    for (int n = 0; n &lt; 5; ++n)
    {
        printf("%c", *p ? *p : ' ');
        ++p;
    }

    printf("\n", str);
}
</code></pre>

<p>结果输出：</p>

<pre><code>73 61 00 63 68  sa ch
73 61 00 00 00  sa
</code></pre>

<p>可见用strcpy拷贝时，ch被忽略了，但是memcpy也将它拷贝过来了。</p>

<p>详细讨论在<a href="http://stackoverflow.com/questions/2898364/strcpy-v-s-memcpy">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse 调试中的五种断点]]></title>
    <link href="http://calvinlee.github.io/blog/2013/01/28/eclipse-debug-break-points/"/>
    <updated>2013-01-28T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/01/28/eclipse-debug-break-points</id>
    <content type="html"><![CDATA[<p>Eclipse调试支持五种不同的断点，这些断点都可以通过Run主菜单下的选项来添加或者删除。</p>

<h3>Line breakpoints</h3>

<p>Line breakpoints就是我们平时使用最多的一种断点类型，它以代码行为单位，代码执行到这一行时就会被suspend。有两个比较有用的属性：</p>

<ul>
<li>Condition breakpoint
为该断点添加一个条件，只有当这个条件成立时才会suspend</li>
<li>Hit count
指定一个整数值N，只有当这个断点被执行过的次数达到N次时才会suspend。</li>
</ul>


<h3>Watchpoint</h3>

<p>Watchpoint针对的是变量。如果我们对程序运行的过程不关心，而对某个关键变量的值的变化比较关心，那么我们可以对这个变量设置一个Watchpoint, 同时指定它的Access和Modification属性用来执行这个变量被访问时suspend还是被修改时suspend。</p>

<p>注意：<br/>
Android的Dalvik虚拟机目前还不支持这种breakpoint。</p>

<h3>Method breakpoints</h3>

<p>Method breakpoints用来指定针对一个方法的断点。他有两个属性：</p>

<ul>
<li>Entry：当进入该方法时suspend</li>
<li>Exit：当执行玩该方法时suspend</li>
</ul>


<h3>Exception breakpoints</h3>

<p>指定当某个exception发生时suspend当前线程。</p>

<h3>Class Load breakpoints</h3>

<p>指定当某个类被虚拟机加载时suspend当前线程。</p>

<p>以上五种断点都可以在Breakpoints 视图中查看，可以通过右上角的菜单，Group by，选择Breakpoint types，这样可以按照这五种类型来对当前所有的Breakpoint进行分类查看，比较方便。</p>

<p><a href="http://calvinlee.github.io/images/eclipse-debug.png"><img src="http://calvinlee.github.io/images/eclipse-debug.png" alt="/images/eclipse-debug.png" /></a></p>

<h3>Reference</h3>

<ul>
<li><a href="http://www.vogella.com/articles/EclipseDebugging/article.htm">http://www.vogella.com/articles/EclipseDebugging/article.htm</a></li>
<li><a href="http://developer.51cto.com/art/201111/302928.htm">http://developer.51cto.com/art/201111/302928.htm</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse Content assist失效解决]]></title>
    <link href="http://calvinlee.github.io/blog/2013/01/28/eclipse-content-assist/"/>
    <updated>2013-01-28T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/01/28/eclipse-content-assist</id>
    <content type="html"><![CDATA[<p>今天发现eclipse的conent assist的默认键Ctrl + Space与系统输入法冲突，于是打开Window &ndash;> Preference &ndash;> Keys，将content assist改为Alt + /，然而发现还是不起作用，最后找到解决方法：<br/>
Window &ndash;> Preference &ndash;> Keys &ndash;> Word Completion &ndash;> Unbind Command<br/>
然后apply。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android消息处理机制理解]]></title>
    <link href="http://calvinlee.github.io/blog/2013/01/20/android-handler-looper-message/"/>
    <updated>2013-01-20T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2013/01/20/android-handler-looper-message</id>
    <content type="html"><![CDATA[<p>Android的消息处理机制是很多功能实现的基础，如UI绘制，键盘事件传递等等。在实现上，涉及到的类有Handler, Message, Looper等等，本篇研究Android消息处理机制的内部实现细节。</p>

<h3>UI线程消息循环的启动</h3>

<p>Android所谓UI线程的启动位于ActivityThread.java，在其main方法中会启动这个消息循环：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Looper</span><span class="o">.</span><span class="na">prepareMainLooper</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sMainThreadHandler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sMainThreadHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ActivityThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ActivityThread</span><span class="o">();</span>
</span><span class='line'>    <span class="n">thread</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先调用<code>Looper.prepareMainLooper()</code>方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Initialize the current thread as a looper, marking it as an</span>
</span><span class='line'><span class="cm">     * application&#39;s main looper. The main looper for your application</span>
</span><span class='line'><span class="cm">     * is created by the Android environment, so you should never need</span>
</span><span class='line'><span class="cm">     * to call this function yourself.  See also: {@link #prepare()}</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepareMainLooper</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">prepare</span><span class="o">();</span>
</span><span class='line'>        <span class="n">setMainLooper</span><span class="o">(</span><span class="n">myLooper</span><span class="o">());</span>
</span><span class='line'>        <span class="c1">// main looper是不允许退出的，否则应用程序就没得玩了</span>
</span><span class='line'>        <span class="n">myLooper</span><span class="o">().</span><span class="na">mQueue</span><span class="o">.</span><span class="na">mQuitAllowed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>     <span class="cm">/** Initialize the current thread as a looper.</span>
</span><span class='line'><span class="cm">      * This gives you a chance to create handlers that then reference</span>
</span><span class='line'><span class="cm">      * this looper, before actually starting the loop. Be sure to call</span>
</span><span class='line'><span class="cm">      * {@link #loop()} after calling this method, and end it by calling</span>
</span><span class='line'><span class="cm">      * {@link #quit()}.</span>
</span><span class='line'><span class="cm">      * </span>
</span><span class='line'><span class="cm">      * prepare方法将实例化一个Looper对象，并保存到一个ThreadLocal变量里, 这个</span>
</span><span class='line'><span class="cm">      * looper稍后可以通过myLooper()方法取出</span>
</span><span class='line'><span class="cm">      */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;Only one Looper may be created per thread&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="n">Looper</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Looper</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// 初始化一个消息队列，其实现稍后解释</span>
</span><span class='line'>        <span class="n">mQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MessageQueue</span><span class="o">();</span>
</span><span class='line'>        <span class="n">mRun</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="n">mThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来调用Looper.loop()启动消息循环：</p>

<pre><code>/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    // 取得当前线程关联的looper对象
    Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    MessageQueue queue = me.mQueue;
    ...
    while (true) {
        // 从消息队列中取出下一个需要处理的消息，这里可能会阻塞
        Message msg = queue.next(); // might block
        if (msg != null) {
            if (msg.target == null) {
                // No target is a magic identifier for the quit message.
                return;
            }
            ...
            msg.target.dispatchMessage(msg);
            ...
            msg.recycle();
        }
    }
}
</code></pre>

<h3>消息队列的建立</h3>

<p>每一个looper对象对应一个MessageQueue对象，Looper对象在这个消息队列上loop。每个消息是一个Message对象，而对这个消息队列的引用也是一个Message对象：</p>

<pre><code>Message mMessages;
</code></pre>

<p>每个Message对象内部也有一个Message对象的引用，指向队列中的下一个message对象，这些message形成了一个单向队列。<strong>这个队列是按照message.when的大小顺序排列的</strong>。队首的消息是最先发生的。</p>

<p>MessageQueue另外还有一个重要的变量：</p>

<pre><code>private int mPtr; // used by native code
</code></pre>

<p>每个MessageQueue在native层对应有一个C++的实现NativeMessageQueue，位于android_os_MessageQueue.cpp，Java层的MessageQueue的mPtr保存的就是这个对象的指针。</p>

<p>MessageQueue的构造方法为：</p>

<pre><code>MessageQueue() {
    nativeInit();
}
</code></pre>

<p>nativeInit()方法在android_os_MessageQueue.cpp中实现：</p>

<pre><code>static void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (! nativeMessageQueue) {
        jniThrowRuntimeException(env, "Unable to allocate native queue");
        return;
    }

    // 将指针值设置给Java层MessageQueue的mPtr变量
    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);
}
</code></pre>

<p>NativeMessageQueue没有太多逻辑实现，它作为C++层的Looper对象的包装类。</p>

<p>C++层的Looper对象实现为framework/base/libs/utils/Looper.cpp:</p>

<pre><code>Looper::Looper(bool allowNonCallbacks) :
       mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
       mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
   int wakeFds[2];
   int result = pipe(wakeFds);
   LOG_ALWAYS_FATAL_IF(result != 0, "Could not create wake pipe.  errno=%d", errno);

   mWakeReadPipeFd = wakeFds[0];
   mWakeWritePipeFd = wakeFds[1];

   result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
   LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake read pipe non-blocking.  errno=%d",
           errno);

   result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
   LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake write pipe non-blocking.  errno=%d",
           errno);

   // Allocate the epoll instance and register the wake pipe.
   mEpollFd = epoll_create(EPOLL_SIZE_HINT);
   LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, "Could not create epoll instance.  errno=%d", errno);

   struct epoll_event eventItem;
   memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
   eventItem.events = EPOLLIN;
   eventItem.data.fd = mWakeReadPipeFd;
   result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
   LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake read pipe to epoll instance.  errno=%d",
           errno);
}
</code></pre>

<p>这里先通过pipe系统调用创建了一个管道，这个管道非常重要：<br/>
当当前线程没有新的消息需要处理时，它会睡眠在管道的读端文件描述符上，直到有新消息到来为止；另一方面，当其他线程向这个线程的消息队列发送一个消息后，其他线程会在这个管道的写端文件描述符上写入数据，这样导致等待在读端文件描述符的looper唤醒，然后对消息队列中的消息进行处理。但是，它对其他线程写入写端文件描述符的数据是什么并不关心，因为这些数据仅仅是为了唤醒它而已。</p>

<h3>开启消息循环</h3>

<p>调用Looper.loop()开启消息循环，前面看到，loop()方法从next()#MessageQueue获取下一个待处理的消息：</p>

<pre><code>final Message next() {
    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;

    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        // 这个方法可能会阻塞，一旦返回，说明有新的message可以处理了，第一次进来nextPollTimeoutMillis为0，表示不作等待，立即返回。
        nativePollOnce(mPtr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            final Message msg = mMessages;
            if (msg != null) {
                final long when = msg.when;
                // 如果队首的消息的when小于当前时间，说明这个消息已经过期了，需要马上处理。
                if (now &gt;= when) {
                    mBlocked = false;
                    mMessages = msg.next;
                    msg.next = null;
                    if (false) Log.v("MessageQueue", "Returning message: " + msg);
                    msg.markInUse();
                    return msg;
                } else {
                    // 计算出还要睡眠多长时间以后再取出下一个消息
                    nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);
                }
            } else {
                nextPollTimeoutMillis = -1;
            }

            ...

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>

<p><code>nativePollOnce(mPtr, nextPollTimeoutMillis);</code> 方法用来检查当前线程的消息队列是否有新的消息需要处理, nextPollTimeoutMillis表示如果没有发现新的消息，当前线程需要睡眠的时间，如果等于-1，表示它需要进入无限睡眠，直到被其他线程唤醒为止。</p>

<p>nativePollOnce函数在C++层的Looper对象的实现为pollOnce()，进而调用pollInner():</p>

<pre><code>int Looper::pollInner(int timeoutMillis) {
    // Poll.
    int result = ALOOPER_POLL_WAKE;
    mResponses.clear();
    mResponseIndex = 0;

    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
    ...
    // 检查是哪个文件描述符上发生了IO事件
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                LOGW("Ignoring unexpected epoll events 0x%x on wake read pipe.", epollEvents);
            }
        } else {
        ...
        }
    }
    return result;
}
</code></pre>

<p>如果是mWakeReadPipeFd上发生了IO事件，说明有其它线程在mWakeWritePipeFd上写入了数据，接下来在awoken()函数中读取这些数据，这样在后续有线程写入数据时可以被再次唤醒：</p>

<pre><code>void Looper::awoken() {
    ... 
    char buffer[16];
    ssize_t nRead;
    do {
        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
    } while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer));
}
</code></pre>

<p>这里只是将数据读出，它并不关心这些数据是什么。</p>

<h3>消息发送过程</h3>

<p>发送消息最常见的方法就是使用sendMessage()#Handler, 这个方法最终会调用enqueueMessage()#MessageQueue.java:</p>

<pre><code>final boolean enqueueMessage(Message msg, long when) {

        msg.when = when;
        //Log.d("MessageQueue", "Enqueing: " + msg);
        Message p = mMessages;
        if (p == null || when == 0 || when &lt; p.when) {
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked; // new head, might need to wake up
        } else {
            Message prev = null;
            while (p != null &amp;&amp; p.when &lt;= when) {
                prev = p;
                p = p.next;
            }
            msg.next = prev.next;
            prev.next = msg;
            needWake = false; // still waiting on head, no need to wake up
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}
</code></pre>

<p>这个方法将新的message插入到消息队列中，并根据需要唤醒native的looper线程。消息的插入分为四种情况：</p>

<ul>
<li>消息队列是一个空队列；</li>
<li>新消息的when等于0，表示需要立即处理；</li>
<li>新消息的when小于队首消息的when；</li>
<li>新消息的when大于或者等于队首消息的when；</li>
</ul>


<p>前三种情况只需要将新消息插入到队首即可，并需要立即唤醒looper对这个新消息进行处理。第四种情况需要插入到队列中的合适位置，并且不需要唤醒looper。<br/>
唤醒looper通过nativeWake()方法实现：
looper.cpp:</p>

<pre><code>void Looper::wake() {
    ssize_t nWrite;
    do {
        nWrite = write(mWakeWritePipeFd, "W", 1);
    } while (nWrite == -1 &amp;&amp; errno == EINTR);

    if (nWrite != 1) {
        if (errno != EAGAIN) {
            LOGW("Could not write wake signal, errno=%d", errno);
        }
    }
}
</code></pre>

<p>唤醒的过程就是望管道的写文件描述符mWakeWritePipeFd写入一些数据即可，这里写入了一个&#8221;W&#8221;字符，这样等待在管道另一端的正在睡眠的线程就会被唤醒，从而导致队首的消息被取出进行处理。</p>

<h3>HanderThread</h3>

<p>HandlerThread最重要的特点是它的looper是在一个子线程中loop的，从而不会阻塞UI线程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Epoch 与 时间字符串的转换]]></title>
    <link href="http://calvinlee.github.io/blog/2012/11/29/convertion-between-epoch-and-regular-time/"/>
    <updated>2012-11-29T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/11/29/convertion-between-epoch-and-regular-time</id>
    <content type="html"><![CDATA[<h3>字符串 &mdash;> Epoch</h3>

<pre><code>$ date -d "2012/11/29" +%s
1354118400
</code></pre>

<h3>Epoch &mdash;> 字符串</h3>

<pre><code>$ date -d@1354118400
Thu Nov 29 00:00:00 CST 2012
</code></pre>

<p>或者加上格式控制：</p>

<pre><code>$ date -d@1354118400 '+%Y-%m-%d %H:%M:%S'
2012-11-29 00:00:00
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git tips and tricks]]></title>
    <link href="http://calvinlee.github.io/blog/2012/10/18/git-tricks/"/>
    <updated>2012-10-18T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/10/18/git-tricks</id>
    <content type="html"><![CDATA[<h3>在提交历史中查找指定文本</h3>

<pre><code>git log -G'password' --all
</code></pre>

<p>or</p>

<pre><code>git rev-list --all | (
while read revision; do
    git grep -F 'password' $revision
done
)
</code></pre>

<p>or</p>

<pre><code>for revision in `git rev-list --all`; 
do
    git grep -F 'password' $revision;
done
</code></pre>

<p>or
<code>git log -S'bad\_code' path/to/file</code> 查看指定代码片段在哪个版本出现过。
<code>git blame path/to/file</code>: 查看指定文件的每一行的最后修改时间是在哪个版本，但不能查看删除的行或者被替换的行
参见man git-blame.</p>

<h3>git commit</h3>

<p><code>git commit -c &lt;commit&gt;</code>  reedit commit message of <commit>
<code>git commit -C &lt;commit&gt;</code>  reuse commit message of <commit></p>

<h3>git底层命令</h3>

<p>git ls-tree<br/>
git write-tree<br/>
git ls-files<br/>
git cat-file<br/>
git rev-parse</p>

<p>.git/refs 保存所有引用的命名空间
.git/refs/heads 所有的本地分支</p>

<p>git commit &mdash;allow-empty &mdash;amend</p>

<p>[TODO] strace命令</p>

<p>.git/index 包含文件索引的目录树，记录了文件名和文件的状态信息，文件的内容存储在.git/objects中，文件索引建立了文件和对象库中的文件对象之间的对应关系。</p>

<p>git checkout . / git checkout &mdash; <file><br/>
丢弃workspace中的内容，保留暂存区的内容</p>

<p>git checkout HEAD . / git checkout HEAD <file><br/>
用HEAD指向的commit中的内容替代workspace和暂存区的内容，这将导致当前workspace和暂存区的内容被丢弃。</p>

<h3>使用git reflog挽回错误的reset</h3>

<p>git reflog<br/>
git reflog show master</p>

<p>分支的变更记录都会被记录在.git/logs/refs下，通过 git reflog命令可以获得分支的历史变更记录，然后可以通过git reset 命令将HEAD任意重置到任意一个提交。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 字符串的==和equals]]></title>
    <link href="http://calvinlee.github.io/blog/2012/10/16/string-interning/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/10/16/string-interning</id>
    <content type="html"><![CDATA[<h3>实例</h3>

<p>问题起源于这段代码：</p>

<pre><code>if (Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED) {
    Log.d(TAG, "mounted");
} else {
    Log.d(TAG, "umounted");
}
</code></pre>

<p>在SD卡处于mounted的状态下，这个case打印出umounted.</p>

<h3>问题</h3>

<p>现在SD卡处于mounted的状态，所以Environment.getExternalStorageState()方法会返回&#8221;mounted&#8221;。<br/>
跟踪Environment.getExternalStorageState方法的实现，如果SD卡处于mounted的状态，该方法返回Environment.MEDIA_MOUNTED这个字符串常量。
那么问题是，Environment.MEDIA_MOUNTED是一个字符串常量，一个字符串常量在JVM中只有一份，== 符号比较的是两边的对象是否是同一个引用，这样来说这里应该输出&#8221;mounted&#8221;才对，为什么会输出&#8221;umounted&#8221;呢？也就是说等号两边的两个字符串不是同一个引用。</p>

<p>原因在于只有在编译期确定的字符串常量才会被放进常量池，这个常量池会被保存在class文件中，稍后被JVM加载。而对于运行时才生成的字符串是不会放入常量池的。Environment.getExternalStorageState()方法返回的字符串虽然是一个字符串常量，但是这个常量在编译期并未确定，所以该方法返回的字符串不是从常量池中取得的。</p>

<p><code>String.intern()</code>方法用于在运行时将一个字符串加入常量池中，所以对这个例子，<code>Environment.getExternalStorageState().intern() == Environment.MEDIA\_MOUNTED</code>才会返回true。</p>

<h3>Reference</h3>

<ul>
<li><a href="http://en.wikipedia.org/wiki/String_interning">http://en.wikipedia.org/wiki/String_interning</a></li>
<li><a href="http://blog.csdn.net/jcc3120/article/details/2118870">http://blog.csdn.net/jcc3120/article/details/2118870</a></li>
<li><a href="http://stackoverflow.com/questions/767372/java-string-equals-versus">http://stackoverflow.com/questions/767372/java-string-equals-versus</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c语言字符串定义与初始化]]></title>
    <link href="http://calvinlee.github.io/blog/2012/08/05/two-ways-of-defining-strings-in-c/"/>
    <updated>2012-08-05T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/08/05/two-ways-of-defining-strings-in-c</id>
    <content type="html"><![CDATA[<h3>字符串的两种定义方式</h3>

<ol>
<li><p>char数组</p>

<p> char sa[] = &ldquo;hello world&rdquo;;</p></li>
<li><p>char指针</p>

<p> char *sp = &ldquo;hello world&rdquo;;</p></li>
</ol>


<p>这两种方式都产生了一个&#8221;hello world&#8221;的<strong>字符串常量</strong>,字符串常量存储在静态存储区中，静态存储区中的内容在程序运行的整个过程中都存在，而且只存储一份。</p>

<h3>数组与指针的关系</h3>

<p>在第一种定义中，字符串常量在编译时就已经分配好了空间，但直到运行时才会为数组分配存储空间，这时，存储在静态存储区中的字符串常量会被拷贝一份到数组中，此后，数组名sa与&amp;sa[0]等价。重要的是，sa是一个常量，你不能修改sa的值，你可以通过sa+1来标识数组里的下一个元素，也可以修改数组里的元素。然而，sa++是不允许的，因为自增运算符只能作用于变量而不是常量。</p>

<p>第二种定义中，程序运行时只为指针变量sp分配了存储空间，用来字符串常量&#8221;hello world&#8221;的地址，这时，字符串常量没有被拷贝。sp的值是可以改变的，如++sp将指向字符e。</p>

<p>总之，数组初始化是从静态存储区中把一个字符串拷贝给数组，而指针初始化只是复制这个字符串的地址。</p>

<h3>示例</h3>

<pre><code>#include &lt;stdio.h&gt;

int main(int args, char **argv) {
    char sa[] = "hello world";
    char *sp = "hello world";

    // sa++; 错误，sa是常量
    sp++;

    sa[1] = 'M';
    *(sa+2) = 'X';
    // sp[1] = 'M'; // 错误，不能修改常量值

    printf("%s\n", sa);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言函数指针与指针函数]]></title>
    <link href="http://calvinlee.github.io/blog/2012/08/05/c-function-pointer/"/>
    <updated>2012-08-05T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/08/05/c-function-pointer</id>
    <content type="html"><![CDATA[<pre><code>#include &lt;stdio.h&gt;

int bar(int, char*);

// 指针函数
char *echo_hello(char *s) {
    char *result;
    int len = strlen(s) + strlen("hello ") + 1;
    result = (char *)malloc(len * sizeof(char));
    memset(result,0, len * sizeof(char));
    snprintf(result, len, "%s%s", "hello ", s);
    return result;
}

int main(int args, char **argv) {
    // 函数指针
    int  (*foo) (int, char *);

    foo = bar;
    foo = &amp;bar;

    foo(2, "hello world");
    (*foo)(2, "hello world");

    printf("%s\n", echo_hello("programmer!"));
}

int bar(int a, char *s) {
    printf("calling bar, int=%d, string=%s\n", a, s);
}
</code></pre>

<h3>Reference</h3>

<p><a href="http://blog.csdn.net/porscheyin/article/details/3461632/">http://blog.csdn.net/porscheyin/article/details/3461632/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用lvm管理磁盘分区]]></title>
    <link href="http://calvinlee.github.io/blog/2012/07/05/use-lvm-to-extends-disk-capacity/"/>
    <updated>2012-07-05T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/07/05/use-lvm-to-extends-disk-capacity</id>
    <content type="html"><![CDATA[<p>最近在给新同学安装Ubuntu系统后发现有的同学home分区空间不够了，于是研究了下利用lvm对home空间进行扩容。<br/>
lvm的概念介绍来自<a href="http://hi.baidu.com/sinyo/blog/item/d793be3e866682f9828b13c6.html">这里</a>.</p>

<p>LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volume group），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logical volumes），并进一步在逻辑卷组上创建文件系统。管理员通过LVM可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配，例如按照使用用途进行定义：“development”和“sales”，而不是使用物理磁盘名“sda”和“sdb”。而且当系统添加了新的磁盘，通过LVM管理员就不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可。</p>

<hr />

<h3>lvm的基本组成</h3>

<p>lvm包括以下几个概念：</p>

<ul>
<li>Physical volume (PV)<br/>
指代磁盘上的物理分区</li>
<li>Volume group (VG)<br/>
VG类似与物理硬盘，由多个物理分区组成，可以在VG上创建一个或者多个逻辑卷（LV）</li>
<li>Logical volume (LV)<br/>
在VG的基础上划分出来的逻辑分区，在这个分区上可以建立文件系统，如home</li>
<li>Physical extent (PE)<br/>
每个逻辑卷被划分的最小可寻址单元，一般为4MB。</li>
</ul>


<p>接下来记录一下对home分区进行扩容的过程。</p>

<h3>准备工作</h3>

<p>已有的环境：<br/>
/dev/sda5 是一块windows分区，格式为fat32;<br/>
/dev/sda9 为当前home所在的分区，格式为ext4.<br/>
现在需要把/dev/sda5合并到home分区中。在建立lvm分区之前，需要备份这两块分区中的数据，因为之后的操作会对这两块分区进行格式化。</p>

<p>首先备份两块分区的数据，重启机器进入recovery模式，以root用户登录，卸载home所在的/dev/sda9</p>

<pre><code># umount /home
</code></pre>

<h3>安装lvm</h3>

<pre><code># apt-get install lvm2
</code></pre>

<h3>修改物理分区类型为8e</h3>

<p>作为PV的物理分区类型必须为8e，表示这是一块lvm的物理分区。我们使用fdisk对/dev/sda5和/dev/sda9这两个物理分区的分区类型进行修改。</p>

<pre><code># fdisk /dev/sda

WARNING: DOS-compatible mode is deprecated. It's strongly recommended to
         switch off the mode (command 'c') and change display units to
         sectors (command 'u').

Command (m for help): t
Partition number (1-10): 5
Hex code (type L to list codes): 8e
Changed system type of partition 5 to 8e (Linux LVM)
Command (m for help): t
Partition number (1-10): 9
Hex code (type L to list codes): 8e
Changed system type of partition 9 to 8e (Linux LVM)
Command (m for help): w       //将修改写入磁盘
</code></pre>

<p>最后<code>fdisk -l</code>查看一下修改后的分区。</p>

<h3>创建物理卷</h3>

<pre><code># pvcreate /dev/sda5
pvcreate -- physical volume "/dev/sda5" successfully created
# pvcreate /dev/sda9
pvcreate -- physical volume "/dev/sda9" successfully created
# pvdisplay
</code></pre>

<h3>创建卷组</h3>

<pre><code># vgcreate lvm_sda /dev/sda5 // 以/dev/sda5为基础创建一个名为lvm_sda的卷组
# vgextend lvm_sda /dev/sda9 // 将/dev/sda9添加进lvm_sda卷组
# vgdisplay lvm_sda
</code></pre>

<h3>创建逻辑卷</h3>

<pre><code># lvcreate -L 150G lvm_sda -n lvolhome
</code></pre>

<p>这里在lvm_sda上创建了一个150G的名为lvolhome的逻辑卷,这时会生成/dev/lvm_sda/lvolhome设备节点。</p>

<h3>创建文件系统</h3>

<pre><code># mkfs.ext4 /dev/lvm_sda/lvolhome
</code></pre>

<p>然后将其挂载到/home，并创建对应用户的home目录。</p>

<pre><code># mount /dev/lvm_sda/lvolhome /home
# cd /home
# mkdir calvin
# chown -R calvin:calvin calvin/
</code></pre>

<h3>设置开机挂载逻辑卷</h3>

<pre><code># vi /etc/fstab
</code></pre>

<p>删除已有的home挂载信息，添加：</p>

<pre><code>/dev/lvm_sda/lvolhome /home ext4 defaults 0 2
</code></pre>

<p>重启系统，done。</p>

<h3>Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/jianghuyue/article/details/6001957">http://blog.csdn.net/jianghuyue/article/details/6001957</a></li>
<li><a href="http://www.linuxhomenetworking.com/wiki/index.php/Quick_HOWTO_:_Ch27_:_Expanding_Disk_Capacity">http://www.linuxhomenetworking.com/wiki/index.php/Quick_HOWTO_:_Ch27_:_Expanding_Disk_Capacity</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[setComponentEnabledSetting doesn't work on widget]]></title>
    <link href="http://calvinlee.github.io/blog/2012/06/19/setComponentEnabledSetting-doesnt-work-on-widget/"/>
    <updated>2012-06-19T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/06/19/setComponentEnabledSetting-doesnt-work-on-widget</id>
    <content type="html"><![CDATA[<h3>需求</h3>

<p>有一个系统属性disable_widget用来标识是否需要禁用某个widget，如果是，那么禁用某个widget.</p>

<h3>实现与问题</h3>

<p><code>PackageManager.setComponentEnabledSetting</code> 可以用来禁用某个组件，包括activity，receiver等等。被禁用的组件会被持久化到/data/system/packages.xml中，如：</p>

<pre><code>&lt;package name="com.android.setupwizard" codePath="/system/app/SetupWizard.apk" nativeLibraryPath="/data/data/com.android.setupwizard/lib" flags="1" ft="13349457a90" it="13349457a90" ut="13349457a90" version="130" userId="10016"&gt;
  &lt;sigs count="1"&gt;
  &lt;cert index="0" /&gt;
  &lt;/sigs&gt;
  &lt;disabled-components&gt;
  &lt;item name="com.android.setupwizard.SetupWizardActivity" /&gt;
  &lt;/disabled-components&gt;
&lt;/package&gt;
</code></pre>

<p>因为widget实际上就是个reveiver，它接收android.appwidget.action.APPWIDGET_UPDATE的action，所以开始的思路是：<br/>
创建一个BroadcastReceiver，接收Intent.ACTION_BOOT_COMPLETED这个动作，从而在启动完成后调用SystemProperties.get(&ldquo;disable_widget&rdquo;)，如果需要禁用这个widget，那么调用：</p>

<pre><code>PackageManager.setComponentEnabledSetting(widgetComponentName，PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                PackageManager.DONT_KILL_APP);
</code></pre>

<p>但是问题是，调用这个方法disable掉这个widget后，发现必须把设备重启之后才能生效&hellip;<br/>
经过一番挖掘，发现问题出在com.android.server.AppWidgetService.java。</p>

<p>开机后，SystemServer会调用AppWidgetService的systemReady()方法，这个方法通过PackageManager查询所有的widget receiver组件，保存到mInstalledProviders变量列表中，并持久化widget信息到/data/system/appwidgets.xml中。
而在Launcher上长按添加widget时的那个widget列表信息也是通过AppWidgetService取得mInstalledProviders列表。</p>

<p>问题在于我们通过PackageManager.setComponentEnabledSetting（）禁用掉某个widget后，packagemanager确实将这个组件disable了，但是AppWidgetService却没有去从packagemanager reload widget信息，这就导致了mInstalledProviders中保存的widget信息还是开机时load进来的那些信息，并没有与pm进行同步。直到下一次开机调用systemReady重新加载widget信息才会刷新这个列表。</p>

<h3>Reference</h3>

<ul>
<li><a href="http://code.google.com/p/android/issues/detail?id=6533">Dynamically enabling or disabling a widget with PackageManager.setComponentEnabledSetting does not work</a></li>
<li><a href="http://blog.csdn.net/yinlijun2004/article/details/6136108">http://blog.csdn.net/yinlijun2004/article/details/6136108</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[multipart/form-data与application/x-www-form-urlencoded]]></title>
    <link href="http://calvinlee.github.io/blog/2012/06/06/multipart-formdata-and-application-x-www-form-urlencoded/"/>
    <updated>2012-06-06T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/06/06/multipart-formdata-and-application-x-www-form-urlencoded</id>
    <content type="html"><![CDATA[<p>在浏览器上提交表单时，根据提交的方式，get或者post，表单数据被封装进url或者http头中，这是http请求的Content-Type字段值默认为<code>application/x-www-form-urlencoded</code>。</p>

<pre><code>POST /upload HTTP/1.1
Host: localhost:8080
Origin: http://localhost:8080
User-Agent: Mozilla/5.0 (X11; U; Linux x86_64; en-us) AppleWebKit/531.2+ (KHTML, like Gecko) Version/5.0 Safari/531.2+
Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
Referer: http://localhost:8080/
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip
Cookie: JSESSIONID=18DE3AD950262E1EDA9A453A8C3BF430
Content-Length: 14

username=scott

HTTP/1.1 
200 OK
Server: Apache-Coyote/1.1
Content-Length: 0
Date: Wed, 06 Jun 2012 06:31:20 GMT
</code></pre>

<p>这种情况下在服务器端使用<code>request.getParameter("username")</code>就可以取出scott这个值。</p>

<p>当需要通过表单上传文件时，这时enctype必须为<code>multipart/form-data</code>或者<code>multipart/mixed</code>。比如：</p>

<pre><code>&lt;form method="post" action="upload"
    enctype="multipart/form-data"&gt;
        &lt;input type="file" name="upload_file"/&gt;
        &lt;input type="text" name="username"/&gt;
        &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</code></pre>

<p>这时浏览器会以表单为单位将所有提交数据进行分割，并分隔符boundary分隔:</p>

<pre><code>POST /upload HTTP/1.1
Host: localhost:8080
Origin: http://localhost:8080
User-Agent: Mozilla/5.0 (X11; U; Linux x86_64; en-us) AppleWebKit/531.2+ (KHTML, like Gecko) Version/5.0 Safari/531.2+
Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysJagkbbAojjjPOh8
Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
Referer: http://localhost:8080/
Accept-Encoding: gzip
Cookie: JSESSIONID=18DE3AD950262E1EDA9A453A8C3BF430
Content-Length: 33076

------WebKitFormBoundarysJagkbbAojjjPOh8
Content-Disposition: form-data; name="upload_file"; filename="mmssms.db-shm"
Content-Type: application/octet-stream
.....
.....
------WebKitFormBoundarysJagkbbAojjjPOh8
Content-Disposition: form-data; name="username"

scott
------WebKitFormBoundarysJagkbbAojjjPOh8--
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Length: 343
Date: Wed, 06 Jun 2012 06:47:49 GMT
</code></pre>

<p>这时在server端就不能用request.getParameter这种方式获取表单数据了，必须对request的数据进行解码。这部分工作已经有现成的库帮我们做了，比如<a href="http://commons.apache.org/fileupload/">Apache Common Fileupload</a>。</p>

<h3>Reference</h3>

<p><a href="http://zh.wikipedia.org/wiki/MIME">http://zh.wikipedia.org/wiki/MIME</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拉风的vim保存方法]]></title>
    <link href="http://calvinlee.github.io/blog/2012/06/02/write-file-in-vim-without-sudo/"/>
    <updated>2012-06-02T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/06/02/write-file-in-vim-without-sudo</id>
    <content type="html"><![CDATA[<p>用vim编辑root用户的文件时，经常忘了敲sudo，结果保存不了。一个work around是保存为一个临时文件，然后sudo cp回去，不过从现在开始，我们可以这样做，输入：</p>

<pre><code>:w !sudo tee %
</code></pre>

<p>%代表当前编辑文件的文件路径，<code>tee %</code>表示把stdin的输入输入到stdout，同时保存到一个文件。<br/>
<code>w !{cmd}</code>意思是说执行一个外部命令cmd，同时把当前缓冲区的内从通过管道连接到cmd的stdin。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[改善SD卡读取速度]]></title>
    <link href="http://calvinlee.github.io/blog/2012/05/31/improve-sd-card-read-speed/"/>
    <updated>2012-05-31T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/05/31/improve-sd-card-read-speed</id>
    <content type="html"><![CDATA[<p>一年前刷了CM的rom，发现sd卡速度下降了很多，今天看见有人发了一个kernel的patch改善这个问题，原理是修改sys文件系统下的一个read_ahead_kb参数值，这个值指定了每次从SD卡上读取数据时预读的大小。</p>

<pre><code>adb shell 'echo 128 &gt; /sys/devices/virtual/bdi/179:0/read_ahead_kb'
</code></pre>

<p>但这个值也不是越大越好，128是个比较平衡的值，因为在读取小文件的情况下，如果这个值太大，那么预读的数据很大几率是无用的数据，反而降低性能，<a href="http://forum.xda-developers.com/showthread.php?t=1032317">这个</a>帖子有详细的分析。</p>

<p>这个值的定义在/include/linux/mm.h中：</p>

<pre><code>/* readahead.c */
#define VM_MAX_READAHEAD    128 /* kbytes */
#define VM_MIN_READAHEAD    16  /* kbytes (includes current page) */
</code></pre>

<h3>设置开机生效</h3>

<p>注意：重启后这个设置就失效了，为了避免每次开机后都要设置，可以在init.rc脚本中加上：</p>

<pre><code>write /sys/devices/virtual/bdi/179:0/read_ahead_kb 128
</code></pre>

<p>或者利用init.d脚本的支持，在/system/etc/init.d目录下创建一个文件10sdcard:</p>

<pre><code>#!/system/bin/sh
echo 128 &gt; /sys/devices/virtual/bdi/179:0/read_ahead_kb

这样每次开机后都会执行这段脚本。
</code></pre>

<h3>CM支持init.d开机脚本的方法</h3>

<ol>
<li><p>在init.rc的class_start default上加上</p>

<pre><code># Run sysinit
exec /system/bin/sysinit

class_start default
</code></pre></li>
<li><p>建立文件/system/bin/sysinit</p>

<pre><code>#!/system/bin/sh

export PATH=/sbin:/system/sbin:/system/bin:/system/xbin
/system/bin/logwrapper /system/xbin/run-parts /system/etc/init.d
</code></pre></li>
</ol>


<p>然后将启动脚本放在/system/etc/init.d目录下，这些脚本以数字命名，run-parts命令按照顺序排序依次执行这些脚本(cron命令也是利用run-parts命令执行指定目录下的脚本的，参见/etc/crontab)。</p>

<p>其实也可以这样做：<br/>
在init.rc的class_start default上加入</p>

<pre><code>start sysinit
</code></pre>

<p>然后在所有service定义的后面加上：</p>

<pre><code>service sysinit /system/bin/logwrapper /system/xbin/busybox run-parts /system/etc/init.d
    disabled
    oneshot
</code></pre>

<h3>Reference</h3>

<ul>
<li><a href="http://forum.xda-developers.com/showthread.php?t=815557">http://forum.xda-developers.com/showthread.php?t=815557</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用iconv和convmv转换文本编码]]></title>
    <link href="http://calvinlee.github.io/blog/2012/05/31/convmv-and-iconv/"/>
    <updated>2012-05-31T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/05/31/convmv-and-iconv</id>
    <content type="html"><![CDATA[<h3>文本内容编码转换</h3>

<p>文本显示乱码是因为文件本身的编码格式和编辑器打开文本所使用的编码格式不一致，使用iconv命令可以转换文本编码。如：</p>

<pre><code>$ iconv -f coding1 -t coding2 file1 -o file2
-f:指定文件原始编码
-t:指定转换的目标编码
file1:代转换的文件
-o:指定输出文件
</code></pre>

<h3>文件名编码转换</h3>

<p>常常有这样的情况，将一个rar文件解压后中文的文件名显示乱码，显示”invalid encoding“，利用convmv命令可以进行转换：</p>

<pre><code>$ convmv -f gbk -t utf-8 -r --notest path/to/your/file
-f:指定原始编码
-t:指定转换的目标编码
-r:如果目标文件是一个目录，递归处理目录下的文件
--notest:转换后将文件重命名，默认情况下这个命令不会重命名文件
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java动态代理]]></title>
    <link href="http://calvinlee.github.io/blog/2012/05/29/dynamic-proxy/"/>
    <updated>2012-05-29T00:00:00+08:00</updated>
    <id>http://calvinlee.github.io/blog/2012/05/29/dynamic-proxy</id>
    <content type="html"><![CDATA[<h3>概念</h3>

<p>Java动态代理是代理模式的延伸，之所以称为”动态“，是因为我们不用去设计代理类，代理类的字节码在运行时被动态生成后由classloader加载进JVM后运行。<br/>
动态代理相关类有：</p>

<pre><code>java.lang.reflect.Proxy  
这个类的主要作用是在运行时生成代理类的字节码，并通过这个字节码生成代理类对象供客户端使用。  

java.lang.reflect.InvocationHandler  
这个接口只定义了一个invoke方法，它是调用真实的被代理对象的地方，我们可以在这个方法里加上额外的代理逻辑，如果日志记录，访问鉴权等。  

Object invoke(Object proxy, Method method, Object[] args);

proxy参数是生成的代理类对象的引用，就像后面分析的，它的类型是$Proxy0，继承了Proxy类并实现了和被代理对象公共的业务接口。  
method是当前被调用的被代理方法。  
args是当前被调用的被代理方法的参数列表。
</code></pre>

<p><a href="http://calvinlee.github.io/images/dynamic_proxy.png"><img src="http://calvinlee.github.io/images/dynamic_proxy.png" alt="/images/dynamic_proxy.png" /></a></p>

<p>利用动态代理的机制，我们可以实现典型的AOP(Aspect-oriented programming)编程模式，实际上，这也是Spring AOP的实现原理。</p>

<h3>举例</h3>

<p>首先是被代理类和代理类公共的业务接口：</p>

<pre><code>public interface Subject {
    void request();
}
</code></pre>

<p>AOP业务接口：</p>

<pre><code>public interface AopLogger {
    void logBefore();

    void logAfter();
}
</code></pre>

<p>被代理类：</p>

<pre><code>public class RealSubject implements Subject {
    public void request() {
        System.out
                .println("Processing request in real subject...");
    }
}
</code></pre>

<p>委托对象类：</p>

<pre><code>import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class RequestInvocationHandler implements InvocationHandler {
    private Subject originalObj;

    private AopLogger logger;

    public RequestInvocationHandler(Subject originalObj) {
        super();
        this.originalObj = originalObj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // do some processing before the method invocation
        System.out.println("Before requesting real subject...");
        logger.logBefore();
        // TODO:
        // how to use this proxy object?

        // invoke the method
        Object result = method.invoke(originalObj, args);

        // do some processing after the method invocation
        logger.logAfter();
        System.out.println("After requesting real subject...");
        return result;
    }

    public AopLogger getLogger() {
        return logger;
    }

    public void setLogger(AopLogger logger) {
        this.logger = logger;
    }
}
</code></pre>

<p>客户端测试代码：</p>

<pre><code>import java.lang.reflect.Field;
import java.lang.reflect.Proxy;
import java.util.Properties;

public class Client {

    public static void main(String[] args) throws Exception {
        // ***** save proxy class into file *******
        Field field = System.class.getDeclaredField("props");
        field.setAccessible(true);
        Properties props = (Properties) field.get(null);
        props.put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
        // ****************************************

        // TODO:
        // 怎样防止客户端绕过proxy直接调用RealSubject的方法？
        Subject origObj = new RealSubject();
        Subject proxy = (Subject) getProxy(origObj);

        proxy.request();
    }

    private static Object getProxy(Subject origObj) {
        RequestInvocationHandler handler = new RequestInvocationHandler(origObj);
        handler.setLogger(new AopLogger() {

            @Override
            public void logBefore() {
                System.out.println("AOP logger working before...");
            }

            @Override
            public void logAfter() {
                System.out.println("AOP logger working after...");
            }

        });

        // 这里会通过ProxyGenerator类生成代理类的字节码，并由origObj所在的classloader加载进JVM，然后通过反射实例化出一个代理对象
        return Proxy.newProxyInstance(origObj.getClass().getClassLoader(), origObj.getClass()
                .getInterfaces(), handler);
    }

}
</code></pre>

<p>在Client测试代码中加上如下代码后可以将生成的代理类字节码保存到本地文件中：</p>

<pre><code>  Field field = System.class.getDeclaredField("props");
  field.setAccessible(true);
  Properties props = (Properties) field.get(null);
  props.put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
</code></pre>

<p>反编译这个class文件后察看可以更清楚幕后究竟做了什么：</p>

<pre><code>import com.java.demo.dynamic_proxy.Subject;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy
  implements Subject {
  private static Method m1;
  private static Method m3;
  private static Method m0;
  private static Method m2;

  public $Proxy0(InvocationHandler paramInvocationHandler)
    throws {
    super(paramInvocationHandler);
  }

  public final boolean equals(Object paramObject)
    throws {
    try {
      return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();
    }
    catch (Error localError) {
      throw localError;
    }
    catch (Throwable localThrowable) {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }

  public final void request()
    throws {
    try {
      // 转发给InvocationHanlder对象处理
      this.h.invoke(this, m3, null);
      return;
    }
    catch (Error localError) {
      throw localError;
    }
    catch (Throwable localThrowable) {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }

  public final int hashCode()
    throws {
    try {
      return ((Integer)this.h.invoke(this, m0, null)).intValue();
    }
    catch (Error localError) {
      throw localError;
    }
    catch (Throwable localThrowable) {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }

  public final String toString()
    throws {
    try {
      return (String)this.h.invoke(this, m2, null);
    }
    catch (Error localError) {
      throw localError;
    }
    catch (Throwable localThrowable) {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }

  static {
    try {
      m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") });
      m3 = Class.forName("com.java.demo.dynamic_proxy.Subject").getMethod("request", new Class[0]);
      m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
      m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
      return;
    }
    catch (NoSuchMethodException localNoSuchMethodException) {
      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());
    }
    catch (ClassNotFoundException localClassNotFoundException) {
    }
    throw new NoClassDefFoundError(localClassNotFoundException.getMessage());
  }
}
</code></pre>

<h3>Reference</h3>

<ul>
<li><a href="http://chjl2020.iteye.com/blog/517835">http://chjl2020.iteye.com/blog/517835</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
